<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/06/15/hello-world/"/>
    <url>/2020/06/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】顺序表与链表的综合比较</title>
    <link href="/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%BC%E5%90%88%E6%AF%94%E8%BE%83/"/>
    <url>/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%BC%E5%90%88%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<p>&lt;———————————–西北大学mooc摘要————————————-&gt;<br> 1.基于空间的考虑<br>顺序表的存储空间是静态分配的，在程序执行之前必须明确规定它的存储规模。若线性表的长度 n 变化较大，则存储规模难于预先确定。估计过大将造成空间浪费，估计太小又将使空间溢出的机会增多。<br>在静态链表中，初始存储池虽然也是静态分配的，但若同时存在若干个结点类型相同的链表，则它们可以共享空间，使各链表之间能够相互调节余缺，减少溢出机会。动态链表的存储空间是动态分配的，只要内存空间尚有空闲，就不会产生溢出。<br>因此，当线性表的长度变化较大，难以估计其存储规模时，采用动态链表作为存储结构较好。</p><p><strong>存储密度</strong>(Storage Density)是指结点数据本身所占的存储量和整个结点结构所占的存储量之比，即：存储密度=结点数据本身所占的存储量/结点结构所占的存储总量链表中的每个结点，除了数据域外，还要额外设置指针（或游标）域，从存储密度来讲，这是不经济的。</p><p>一般地，存储密度越大，存储空间的利用率就高。显然，顺序表的存储密度<br>为 1，而链表的存储密度小于 1。例如单链表的结点的数据均为整数，指针所占空间和整型量相同，则单链表的存储密度为 50%。因此若不考虑顺序表的备用结点空间，则顺序表的存储空间利用率为 100%，而单链表的存储空间利用率为50%。由此可知，当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。</p><p>2.基于时间的考虑<br>顺序表是由向量实现的，它是一种随机存取结构，对表中任一结点都可以在<br>O (1) 时间内直接地存取，而链表中的结点，需从头指针起顺着链找才能取得。因此，若线性表的操作主要是进行查找，很少做插入和删除时，宜采用顺序表做存储结构。<br>在链表中的任何位置上进行插入和删除，都只需要修改指针。而在顺序表中<br>进行插入和删除，平均要移动表中近一半的结点，尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。因此，对于频繁进行插入和删除的线性表，宜采用链表做存储结构。若表的插入和删除主要发生在表的首尾两端，则宜采用尾指针表示的单循环链表。</p><p>3.基于语言的考虑<br>在没有提供指针类型的高级语言环镜中，若要采用链表结构，则可以使用光<br>标实现的静态链表。虽然静态链表在存储分配上有不足之处，但它是和动态链表一样，具有插入和删除方便的特点。<br>值得指出的是，即使是对那些具有指针类型的语言，静态链表也有其用武之<br>地。特别是当线性表的长度不变，仅需改变结点之间的相对关系时，静态链表比动态链表可能更方便。<br><img src="https://img-blog.csdnimg.cn/20200315062959831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
      <category>线性表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】循环双向静态链表</title>
    <link href="/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%BE%AA%E7%8E%AF.%E5%8F%8C%E5%90%91.%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%BE%AA%E7%8E%AF.%E5%8F%8C%E5%90%91.%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6> 循环链表</td></tr></table><ol><li>定义：首尾相接的链表</li><li>结构：尾结点的指针域指向头结点或表的首元结点</li><li>特点：表中所有结点都链接在一个环上</li><li>判断循环链表空链表的条件：头指针的指针域指向自己（head-&gt;next==head）<table><tr><td bgcolor=#FFC0CB><font  size=5> 循环链表的合并算法</td></tr></table></li></ol><p>算法思路：</p><ol><li>遍历两表找表尾</li><li>将第一表尾链接第二表头，将第二表尾链接第一表头 </li></ol><p><img src="https://img-blog.csdnimg.cn/20200311210658984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">linklist <span class="hljs-title">merge_1</span><span class="hljs-params">(linklist la,linklist lb)</span></span>&#123;<span class="hljs-comment">/*将两个采用头指针的循环单链表的首尾连接起来*/</span>node *p,*q;p=la;q=lb;<span class="hljs-keyword">while</span>(p-&gt;next!=la) p=p-&gt;next;<span class="hljs-comment">/*找到表la的表尾，用p指向它*/</span><span class="hljs-keyword">while</span>(q-&gt;next!=lb) q=q-&gt;next;<span class="hljs-comment">/*找到表lb的表尾，用p指向它*/</span>q-&gt;next=la;<span class="hljs-comment">/*修改表lb的尾指针，使之指向表la的头结点*/</span>p-&gt;next=lb-&gt;next;<span class="hljs-comment">/*修改表la的尾指针，使之指向表lb的第一个结点*/</span><span class="hljs-built_in">free</span>(lb);<span class="hljs-keyword">return</span>(la);&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200311210706579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">linklist <span class="hljs-title">merge_2</span><span class="hljs-params">(linklist ra,linklist rb)</span></span>&#123;<span class="hljs-comment">/*将两个采用尾指针的循环单链表的首尾连接起来*/</span>node *p;p=ra-&gt;next;<span class="hljs-comment">/*保存链表ra的头结点的地址*/</span>ra-&gt;next=rb-&gt;next-&gt;next;<span class="hljs-comment">/*链表rb的开始接待你链到链表ra的终端结点之后*/</span><span class="hljs-built_in">free</span>(rb-&gt;next);rb-&gt;next=p;<span class="hljs-comment">/*链表ra的头结点链到链表rb 的终端节点之后*/</span><span class="hljs-keyword">return</span> rb;<span class="hljs-comment">/*返回新循环链表的尾指针*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6>双向链表</td></tr></table><ol><li><p>定义：链表中每个结点增加一个指向其前驱的指针。每个结点包含两个指针域</p></li><li><p>特点：任一结点均可沿前驱和后继两个方向操作。<br><img src="https://img-blog.csdnimg.cn/20200312051202800.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=6>c语言结构定义</td></tr></table></li></ol><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dnode</span>&#123;</span>elemtype data;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dnode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span>&#125;dnode,*doublelist;</code></pre></div> <table><tr><td bgcolor=#FFC0CB><font  size=6> 操作</td></tr></table> <table><tr><td bgcolor=#99CCFF><font  size=4>1.前插操作 </td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200313040255210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dlinkins</span><span class="hljs-params">(doublelist l,<span class="hljs-keyword">int</span> i,elemtype e)</span></span>&#123;dnode *p,*s;<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;p=l;<span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;(i))<span class="hljs-comment">/*在第i个元素之前插入，则先找到第i个数据元素的存储位置</span><span class="hljs-comment">使p指针指向它*/</span>&#123;p=p-&gt;next;k++; &#125;<span class="hljs-keyword">if</span>(!p)<span class="hljs-comment">/*如果当前位置p为空，表示已找完但还未数到第i个</span><span class="hljs-comment">说明插入位置不合理*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置不合理"</span>);<span class="hljs-keyword">return</span> error; &#125;s=(dnode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(dnode));<span class="hljs-comment">/*为s申请一个新结点并由s指向它*/</span><span class="hljs-keyword">if</span>(s)&#123;s-&gt;data=e;s-&gt;prior=p-&gt;prior;<span class="hljs-comment">//① </span>p-&gt;prior-&gt;next=s;<span class="hljs-comment">//② </span>s-&gt;next=p;<span class="hljs-comment">//③ </span>p-&gt;prior=s;<span class="hljs-comment">//④ </span><span class="hljs-keyword">return</span> TRUE;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE; &#125;</code></pre></div>  <table><tr><td bgcolor=#99CCFF><font  size=4>2.删除操作 </td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200313040713676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dlinkdel</span><span class="hljs-params">(doublelist l,<span class="hljs-keyword">int</span> i,elemtype *e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在双向链表中删除第i个元素，</span></span><span class="hljs-function"><span class="hljs-comment">并将删除的元素保存到变量*e中。*/</span></span><span class="hljs-function"></span>&#123;dnode *p;<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;p=l;<span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;(i))<span class="hljs-comment">/*寻找被删除结点i使p指向它*/</span>&#123;p=p-&gt;next;k++;&#125;<span class="hljs-keyword">if</span>(k!=i)<span class="hljs-comment">/*即循环是因为p-&gt;next=NULL而跳出来的*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除位置i不合理"</span>);<span class="hljs-keyword">return</span> error;&#125;*e=p-&gt;data;p-&gt;prior-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=p-&gt;prior;<span class="hljs-built_in">free</span>(p);<span class="hljs-comment">/*释放被删除结点所占内存空间*/</span><span class="hljs-keyword">return</span> TRUE;&#125;</code></pre></div> <table><tr><td bgcolor=#FFC0CB><font  size=5> 双向循环列表</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200313042242567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=6>静态链表</td></tr></table> <table><tr><td bgcolor=#FFC0CB><font  size=4> 静态链表的基本特征</td></tr></table><ol><li>存储池：定义一个较大的<strong>结构数组</strong>作为备用结点空间</li><li>游标机制：每个结点应该应该含有两个域，data域和next（或者cursor）域。<ul><li>data域用来存放结点的数据信息。</li><li>cuisor域为游标指示器，指示<strong>后继结点在结构数组中的相对位置</strong>（即<strong>数组下标值</strong>）数组的第0个分量可以设计成表的头结点，头结点的cursor域指示了表中第一个结点的位置，cursor值为0表示静态单链表结束。</li></ul></li><li>结点结构<div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxsize <span class="hljs-comment">//链表可能达到的最大长度</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>elemtype data;<span class="hljs-keyword">int</span> <span class="hljs-built_in">cursor</span>;&#125; component,staticlist[maxsize];</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=4>静态链表的插入和删除操作示例</td></tr></table></li></ol><p><img src="https://img-blog.csdnimg.cn/20200313044655434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>插入：</p><ul><li>step1：申请一个空闲空间并置入元素 e，即：使 S[9].data=e</li><li>step2：修改第四个元素的游标域，将 e 插入到链表中。即：S[9].cursor= S[4].cursor，S[4].cursor=9。</li></ul><p>删除：</p><ul><li>若要删除第 8 个元素 h，则先顺着游标链通过记数找到第 7 个元素存储位置 6，令 S[6].cursor=S[7].cursor。</li></ul><p>缺点 ：</p><ul><li>上述例子中未考虑对已释放空间的回收，这样在经过多次插入和删除后，会造成静态链表的“假满”。即表中有很多的空闲空间，但却无法再插入元素。造成这种现象的原因是未对已删除的元素所占的空间进行回收。</li></ul><p>解决方法：</p><ul><li>将所有未被分配的结点空间以及因删除操作而回收的结点空间用游标 链成一个备用静态链表。</li><li>当进行插入操作时，先从备用链表上取一个分量来存放待插入的元素，然后将其插入到已用链表的相应位置。</li><li>当进行删除操作时，则将被删除的结点空间链接到备用链表上以备后用。</li><li>这种方法是指在已申请的大的存储空间中有一个已用的静态单链表，还有一个备用单链表。已用静态单链表的头指针为 0，备用静态单链表的头指针需另设一个变量 av 来表示。</li></ul><table><tr><td bgcolor=#FFC0CB><font  size=6> 基本操作</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4>1.初始化 </td></tr></table>  算法描述：初始化为一个备用静态单链表。<p><img src="https://img-blog.csdnimg.cn/20200313050122667.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>ps：这里的maxsize=11</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">(straticlist space,<span class="hljs-keyword">int</span> *av)</span></span><span class="hljs-function"><span class="hljs-comment">/*构建两个表，已用空间为空表，其余空间为备用空间表*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> k;space[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">cursor</span>=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;(maxsize<span class="hljs-number">-1</span>);k++)&#123;space[k]-&gt;<span class="hljs-built_in">cursor</span>=k+<span class="hljs-number">1</span>&#125; space[maxsize<span class="hljs-number">-1</span>]=<span class="hljs-number">-1</span>;*av=<span class="hljs-number">1</span>;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>2.分配结点 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*从可用区申请新结点*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnode</span> <span class="hljs-params">(staticlis space, <span class="hljs-keyword">int</span> *av)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i;i=*av;*av=space[av].<span class="hljs-built_in">cursor</span>;<span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回可用新结点i </span>&#125;</code></pre></div><ul><li>对系统而言，相当于备用链表中减少一个结点 i。</li><li>对使用者而言，相当于申请得到了一个可用的新结点 i。</li></ul><table><tr><td bgcolor=#99CCFF><font  size=4>3.结点回收 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*备用区回收空闲节点*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freenode</span><span class="hljs-params">(staticlist space,<span class="hljs-keyword">int</span> *av,<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"><span class="hljs-comment">//增加一个新结点k</span></span><span class="hljs-function"></span>&#123;spcae[k].<span class="hljs-built_in">cursor</span>=*av;*av=k;&#125;</code></pre></div><ul><li>对系统而言，回收空闲结点相当于备用链表中增加一个结点 k。</li><li>对使用者而言，相当于释放了一个不用的结点 k。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
      <category>线性表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】应用—一元多项式的表示及相加</title>
    <link href="/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%BA%94%E7%94%A8%E2%80%94%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E7%9B%B8%E5%8A%A0/"/>
    <url>/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%BA%94%E7%94%A8%E2%80%94%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[ <table><tr><td bgcolor=#E6E6FA><font  size=5>  1. 一元多项式的表示</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200315052630347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br> <table><tr><td bgcolor=#E6E6FA><font  size=5>   2. 一元多项式的存储</td></tr></table></p><p> 一元多项式的操作可以利用线性表来处理。因此，一元多项式也有顺序存储和链式存储两种方法。<br> <img src="https://img-blog.csdnimg.cn/20200315052909253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020031505304063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>结点结构体定义如下</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">polynode</span>&#123;</span><span class="hljs-keyword">int</span> coef;<span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>;polynode *next;&#125;polynode,polylist;</code></pre></div> <table><tr><td bgcolor=#E6E6FA><font  size=5>   例：建立一元多项式链式存储算法</td></tr></table><p>【算法思想】通过键盘输入一组多项式的系数和指数，用尾插法建立一元多项式的链表。以输入系数0为结束标注，并约定建立多项式链表时，总是按指数从小到大排序。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">polylist <span class="hljs-title">polycreate</span><span class="hljs-params">()</span> </span>&#123;polynode *head,*rear,*s;<span class="hljs-keyword">int</span> c,e;head=(polynode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(polynode));<span class="hljs-comment">//建立多项式的头结点；</span>rear=head;<span class="hljs-comment">//rear始终指向单链表的尾，便于尾插法建表</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>,&amp;c,&amp;e);<span class="hljs-comment">//键入多项式的系数和指数项</span><span class="hljs-keyword">while</span>(c!=<span class="hljs-number">0</span>)<span class="hljs-comment">//若c=0，则代表多项式的输入结束</span>&#123;s=(polynode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(polynode));<span class="hljs-comment">//申请新的结点</span>s-&gt;coef=c;s-&gt;<span class="hljs-built_in">exp</span>=e;rear-&gt;next=s;<span class="hljs-comment">//在当前表尾做插入 </span>rear=s; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>,&amp;c,&amp;e);&#125;rear-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//将表的最后一个结点的next置NULL，以表示结束</span><span class="hljs-keyword">return</span> (head); &#125;</code></pre></div> <table><tr><td bgcolor=#E6E6FA><font  size=5>  3. 一元多项式的相加运算</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200315054815361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>【算法思想】<br>以单链表polya和polyb分别表示两个一元多项式A和B，A+B的求和运算，就等同于单链表的插入问题（将单链表polyb中的结点插入到单链表polya中），因此“和多项式”中的结点无需另生成。<br>为实现处理，设p，q分别指向单链表polya和polyb的当前项，比较p，q的结点的指数项，由此得到下列运算规则：<br>①若p-&gt;exp &lt; q-&gt;exp，则结点p所指的结点应该是“和多项式”中的一项，另指针后移；</p><p>②若p-&gt;exp = q-&gt;exp，则将两个结点中的系数增加，当和不为零时修改结点p的系数域，释放q结点；若和为零，则和多项式中无此项，从A中删去p结点，同时释放p和q结点。</p><p>③若p-&gt;exp &gt; q-&gt;exp，则结点q所指的结点应该时“和多项式”中的一项，将结点q插入结点p之前，且令指针q在原来的链表上后移</p><p>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">polyadd</span><span class="hljs-params">(polylist polya,polylist polyb)</span></span><span class="hljs-function"><span class="hljs-comment">//将两个多项式相加，然后将和多项式存放在polya中，并将polyb删除</span></span><span class="hljs-function"></span>&#123;polynode *p,*q,*tail,*temp;<span class="hljs-keyword">int</span> sum;p=polya-&gt;next;q=polyb-&gt;next;<span class="hljs-comment">//令p和q分别指向polya和polyb多项式链表中的第一个结点</span>tail=polya;<span class="hljs-comment">//tail指向和多项式的尾结点</span><span class="hljs-comment">/*-----初始化(略)-----*/</span><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>) &#123;<span class="hljs-keyword">if</span>(p-&gt;<span class="hljs-built_in">exp</span>&lt;q-&gt;<span class="hljs-built_in">exp</span>)<span class="hljs-comment">//规则（1）：如果p指向的多项式的指数小于q的指数，将p结点加入到和多项式中</span>&#123;tail-&gt;next=p;tail=p;p=p-&gt;next;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;<span class="hljs-built_in">exp</span>==q-&gt;<span class="hljs-built_in">exp</span>)<span class="hljs-comment">//规则(2)：若指数相等，则相应的系数相加</span>&#123;sum=p-&gt;coef+q-&gt;coef;<span class="hljs-keyword">if</span>(sum!=<span class="hljs-number">0</span>)<span class="hljs-comment">//若系数和非0，则系数和置入结点p，释放结点q，并将指针后移</span>&#123;p-&gt;coef=sum;tail-&gt;next=p;tail=p;p=p-&gt;next;temp=q;q=q-&gt;next;<span class="hljs-built_in">free</span>(temp);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//若系数和为0.删除p，q，并将指针指向下一个结点</span>temp=p;p=p-&gt;next;<span class="hljs-built_in">free</span>(temp);temp=q;q=q-&gt;next;<span class="hljs-built_in">free</span>(temp);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">////规则（3）：如果p指向的多项式的指数大于q的指数，将q结点加入到和多项式中</span>tail-&gt;next=q;tail=q;q=q-&gt;next;&#125;&#125;<span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//多项式A中还有剩余，则将剩余的结点加入到和多项式中</span>&#123;tail-&gt;next=p;tail=p;p=p-&gt;next;&#125; <span class="hljs-keyword">else</span> &#123;tail-&gt;next=q;tail=q;q=-&gt;next;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
      <category>线性表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>习题11-8 单链表结点删除</title>
    <link href="/2020/03/14/%E4%B9%A0%E9%A2%9811-8%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4/"/>
    <url>/2020/03/14/%E4%B9%A0%E9%A2%9811-8%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<p> 本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中所有存储了某给定值的结点删除。</p><div class="hljs"><pre><code>链表结点定义如下：</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span>    <span class="hljs-keyword">int</span> data;    ListNode *next;&#125;;</code></pre></div><div class="hljs"><pre><code>函数接口定义：</code></pre></div><blockquote><p>struct ListNode *readlist();<br>struct ListNode *deletem( struct ListNode *L, int m );</p></blockquote><p>函数readlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。<br>函数deletem将单链表L中所有存储了m的结点删除。返回指向结果链表头结点的指针。</p><div class="hljs"><pre><code>裁判测试程序样例：</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span>    <span class="hljs-keyword">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">next</span>;</span>&#125;;<span class="hljs-function">struct ListNode *<span class="hljs-title">readlist</span><span class="hljs-params">()</span></span>;<span class="hljs-function">struct ListNode *<span class="hljs-title">deletem</span><span class="hljs-params">( struct ListNode *L, <span class="hljs-keyword">int</span> m )</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printlist</span><span class="hljs-params">( struct ListNode *L )</span></span><span class="hljs-function"></span>&#123;     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p</span> = <span class="hljs-title">L</span>;</span>     <span class="hljs-keyword">while</span> (p) &#123;           <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);           p = p-&gt;next;     &#125;     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">L</span> = <span class="hljs-title">readlist</span>();</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);    L = deletem(L, m);    printlist(L);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="hljs"><pre><code>输入样例：10 11 10 12 10 -1         10输出样例：11 12 </code></pre></div><p>答案：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">struct ListNode *<span class="hljs-title">readlist</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//读入一系列正整数，按照读入顺序建立单链表。</span><span class="hljs-keyword">int</span> c,flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//检查输入是否正确</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;c);<span class="hljs-comment">/*建立表头*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">l</span>;</span>l=(struct ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct ListNode));<span class="hljs-keyword">if</span>(c!=(<span class="hljs-number">-1</span>))&#123;l-&gt;data=c;             l-&gt;next=<span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*尾插法建表*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">r</span>;</span>r=l;<span class="hljs-comment">/*r始终动态地指向表尾,初值指向头结点*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">n</span>;</span><span class="hljs-keyword">while</span>(flag) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;c);<span class="hljs-keyword">if</span>(c!=(<span class="hljs-number">-1</span>)) &#123;n=(struct ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct ListNode));n-&gt;data=c;n-&gt;next=<span class="hljs-literal">NULL</span>;r-&gt;next=n;r=n;<span class="hljs-comment">//r就是当前尾结点</span>&#125; <span class="hljs-keyword">else</span> &#123;r-&gt;next=<span class="hljs-literal">NULL</span>;flag=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-function">struct ListNode *<span class="hljs-title">deletem</span><span class="hljs-params">( struct ListNode *L, <span class="hljs-keyword">int</span> m )</span> </span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">h</span>,*<span class="hljs-title">p</span>,*<span class="hljs-title">q</span>;</span>h=L;<span class="hljs-comment">//先保证头结点不是m</span><span class="hljs-keyword">while</span>(h-&gt;data==m&amp;&amp;(h-&gt;next!=<span class="hljs-literal">NULL</span>)) &#123;p=h-&gt;next;<span class="hljs-built_in">free</span>(h);h=p;&#125;<span class="hljs-comment">//如果整个链表都删没了，返回NULL </span><span class="hljs-keyword">if</span>(h-&gt;data==m)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">//删除符合条件的结点</span>p=h;q=p-&gt;next;<span class="hljs-keyword">while</span>(q) &#123;<span class="hljs-keyword">if</span>(q-&gt;data==m) &#123;p-&gt;next=q-&gt;next;<span class="hljs-built_in">free</span>(q);q=p-&gt;next;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> &#123;p=q;q=q-&gt;next;&#125;&#125;<span class="hljs-keyword">return</span> h;&#125;</code></pre></div><blockquote><p>一点小小的流水账吧，纪念一下第一道和数据结构有关的题哈哈哈，我真的很菜。这道题断断续续竟然做了六个多小时…就很离谱，气的眼泪都要掉出来了。写出来其实没有多久，只是一直钻牛角尖想改自己的代码，也看不进去别人写的正确答案。<br>大一之前都没接触过编程，大一上加寒假因为各种nt事浪费了很多时间。过去种种真的很想放下说重新开始，但真的比别人差太多了，实名菜狗弟弟，没办法原谅这样的自己。<br>这段时间早上四点起来听网课敲代码记笔记，不断反省，其实也是强迫症地焦虑，甚至条件反射到不管晚上睡不睡得着早上四点都要起来学习，导致午睡根本起不来，最近只能下午狂喝黑咖＋中高强度运动避免午睡改掉这个辣鸡作息，争取稳定在晚十点半早四点半到五点。<br>还考虑了很久保研/考研/就业的事，学高数/线代/离散/大物/通信真的有压榨我敲代码的时间，但是又不想成绩不好看，毕竟还想拼一拼奖学金x包括还在打辩论，三月份是无差别比赛，就在明天开始抽签，寒假拿了个网辩季军回来还是有点小高兴的哈哈哈虽然和技术没啥关系x。还在准备六级的事，争取大一下就过六级。<br>虽然记录流水账的时候看起来很欢快，但是我永远不会忘记这个春天。如果这二十天的焦虑，痛苦，强迫和抑郁的心情是努力的敲门砖，那我愿意也舍得去尝试，希望，哦不是一定，度过这段日子之后要长长久久地坚持。<br>偷偷努力，要来证明我的选择是对的，而这一切都是-<br>我  值  得。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>PTA</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】单链表及其基本运算和应用</title>
    <link href="/2020/03/11/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2020/03/11/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#99CCFF><font  size=5> 单链表的c语言定义</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>ElemType data;<span class="hljs-comment">/*数据域*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">/*指针域*/</span>&#125; Node,*Linklist;<span class="hljs-comment">/*给node起两个别名，这两个别名等效*/</span>LinkLIst L;<span class="hljs-comment">/*L为单链表的头指针，也称为单链表L*/</span></code></pre></div><p>LinkList 与 Node*同为结构指针类斜体样式型，这两种类型是等价的。</p><p>通常我们习惯上用LinkList说明指针变量，强调它是某个单链表的头指针变量，用<br>Node*来定义指向单链表中节点的指针。</p><table><tr><td bgcolor=#E6E6FA><font  size=6> 单链表的基本运算</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=5> 一、求带头节点单链表的长度</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listlength</span><span class="hljs-params">(linklist L)</span></span>&#123;node *p;p=-&gt;next;j=<span class="hljs-number">0</span>;<span class="hljs-comment">/*用来存放单链表的长度*/</span><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;p=p-&gt;next;j++;&#125;<span class="hljs-keyword">return</span> j;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=6> 二、建表</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=5>1.建立空表 </td></tr></table><div class="hljs"><pre><code class="hljs c">InitList(linklist *L)<span class="hljs-comment">/*建立空表*/</span>&#123;L=(linklist*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));L-&gt;next=<span class="hljs-literal">NULL</span>;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>2.头插法建表 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">linklist <span class="hljs-title">creatfromhead</span><span class="hljs-params">(linklist l)</span></span>&#123;node *s;<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<span class="hljs-comment">/*设置一个标志，初值为1，当输入“$”时，flag为0，建表结束*/</span><span class="hljs-keyword">while</span>(flag)&#123;c=getchar();<span class="hljs-keyword">if</span>(c!=<span class="hljs-string">'$'</span>)&#123;s(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node))<span class="hljs-comment">/*申请新结点s*/</span>s-&gt;data=c;s-&gt;next=L-&gt;next;<span class="hljs-comment">/*将结点s头插入链表L*/</span>L-&gt;next=s; &#125;<span class="hljs-keyword">else</span> flag=<span class="hljs-number">0</span>;&#125;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>3.尾插法建表 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">linklist <span class="hljs-title">createfromtail</span><span class="hljs-params">(linklist L)</span></span>&#123;linklist L;node *r,*s;<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<span class="hljs-comment">/*设置一个标志，初值为1，当输入“$”时，flag为0，建表结束*/</span>r=L;<span class="hljs-comment">/*r指针始终动态指向链表的当前表尾，以便做尾插入，其初值指向头结点*/</span><span class="hljs-keyword">while</span>(flag)&#123;c=getchar();<span class="hljs-keyword">if</span>(c!=<span class="hljs-string">'$'</span>)&#123;s=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));s-&gt;data=c;r-&gt;next=s;r=s;<span class="hljs-comment">/*r就是当前尾结点*/</span>&#125; <span class="hljs-keyword">else</span>&#123;flag=<span class="hljs-number">0</span>;r-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*将最后一个结点的next链域置为空，表示链表结束*/</span>&#125;&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=6> 三、查找</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=5>1.按序号查找 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">node *<span class="hljs-title">get</span><span class="hljs-params">(linklist L,<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"><span class="hljs-comment">/*在带头结点的单链表L中查找第i个结点，</span></span><span class="hljs-function"><span class="hljs-comment">若找到(1&lt;=i&lt;=n),则返回该结点的存储位置，否则返回NULL*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<span class="hljs-comment">/*计数器*/</span>node *p;p=L;<span class="hljs-comment">/*从头结点开始扫描*/</span><span class="hljs-keyword">while</span>((p-&gt;next!=<span class="hljs-literal">NULL</span>)&amp;&amp;(j&lt;i))&#123;p=p-&gt;next;<span class="hljs-comment">/*扫描下一结点*/</span>j++;<span class="hljs-comment">/*已扫描结点计数器*/</span>&#125;<span class="hljs-keyword">if</span>(i==j)<span class="hljs-keyword">return</span> p;<span class="hljs-comment">/*找到了第i个点*/</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*找不到，i&lt;=0或i&gt;n*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>2.按值查找 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">node *<span class="hljs-title">locate</span><span class="hljs-params">(linklist l,elemtype key)</span></span><span class="hljs-function"><span class="hljs-comment">/*在带头结点的单链表L中查找其结点值等于key的结点，</span></span><span class="hljs-function"><span class="hljs-comment">若是找到则返回该结点的位置p，否则返回NULL*/</span></span><span class="hljs-function"></span>&#123;node *p;p=l-&gt;next;<span class="hljs-comment">/*从表中第一个结点比较*/</span><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">if</span>(p-&gt;data!=key)p=p-&gt;next;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-comment">/*找到结点key退出循环*/</span>&#125; <span class="hljs-keyword">return</span> p; &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 四、单链表插入</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inslist</span><span class="hljs-params">(linklist L,<span class="hljs-keyword">int</span> i,elemtype e)</span></span>&#123;node *pre,*s;<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;pre=L;<span class="hljs-keyword">while</span>(pre!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;(i<span class="hljs-number">-1</span>))<span class="hljs-comment">/*在第i个元素之前插入，则先找到第i-1个数据元素的存储位置</span><span class="hljs-comment">使pre指针指向它*/</span>&#123;pre=pre-&gt;next;k++; &#125;<span class="hljs-keyword">if</span>(!pre)<span class="hljs-comment">/*如果当前位置pre为空，表示已找完但还未数到第i个</span><span class="hljs-comment">说明插入位置不合理*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置不合理"</span>);<span class="hljs-keyword">return</span> ERROR; &#125;s=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<span class="hljs-comment">/*为s申请一个新结点并由s指向它*/</span>s-&gt;data=e;<span class="hljs-comment">/*将待插入结点的值e赋给s的数据域*/</span>s-&gt;next=pre-&gt;next;<span class="hljs-comment">/*完成插入操作*/</span>pre-&gt;next=s;<span class="hljs-keyword">return</span> OK; &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 五、单链表删除</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dellist</span><span class="hljs-params">(linklist L,<span class="hljs-keyword">int</span> i,elemtype *e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在带头结点的单链表L中删除第i个元素，</span></span><span class="hljs-function"><span class="hljs-comment">并将删除的元素保存到变量*e中。*/</span></span><span class="hljs-function"></span>&#123;node *p,*r;<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;p=L;<span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;(i<span class="hljs-number">-1</span>))<span class="hljs-comment">/*寻找被删除结点i的前驱结点i-1使p指向它*/</span>&#123;p=p-&gt;next;k++; &#125;<span class="hljs-keyword">if</span>(k!=i<span class="hljs-number">-1</span>)<span class="hljs-comment">/*即循环是因为p-&gt;next=NULL而跳出来的*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除位置i不合理"</span>);<span class="hljs-keyword">return</span> error; &#125;r=p-&gt;next;p-&gt;next=p-&gt;next-&gt;next;*e=r-&gt;data;<span class="hljs-built_in">free</span>(r);<span class="hljs-comment">/*释放被删除结点所占内存空间*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6> 算法应用示例</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=4> 求两个集合的差</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">difference</span><span class="hljs-params">(linklist la,linklist lb)</span> </span>&#123;node *pre,*p,*q,*r;pre=la;p=la-&gt;next;<span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*逐个确定A表一个元素*/</span>q=lb-&gt;next;<span class="hljs-comment">/*查是否属于b表*/</span><span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>&amp;&amp;q-&gt;data!=p-&gt;data) &#123;q=q&gt;next;&#125;<span class="hljs-keyword">if</span>(q!=<span class="hljs-literal">NULL</span>) &#123;r=p;pre-&gt;next=p-&gt;next;p=p-&gt;next;<span class="hljs-built_in">free</span>(r);&#125; <span class="hljs-keyword">else</span> &#123;pre=p;p=p-&gt;next;&#125;&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=4> 带头结点单链表就地逆置问题</td></tr></table>【问题分析】逆置就是使得表中内容由原来的（a1,a2,…，ai-1，ai，ai+1， …，an）变为（an,an-1,…，ai+1，ai，ai-1， …，a1）。就地逆置就是不需要额外申请结点空间，只需要利用原有的表中的节点空间。若对顺序表中的元素进行逆置，可以借助于“交换”前后相应元素；对单链表中的元素进行逆置，则不能按“交换”思路，因为对于链表中第 i 个结点需要顺链查找第 n-i+1(链表长度为 n)个结点，逆置链表的时间复杂度将达 O（n2）。<p>【算法思路】用头插法完成</p><ul><li>【初始化】逆置链表L初始为空表，指针p指向原表当前处理结点</li><li>【头插法】依次取原链表中当前结点p<br>将其作为第一个结点插入到逆置链表L的表头L<br>q为保存原链表当前结点的下一个处理位置</li></ul><p><img src="https://img-blog.csdnimg.cn/20200315094339761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverselist</span><span class="hljs-params">(linklist l)</span></span><span class="hljs-function"><span class="hljs-comment">//逆置带头结点的单链表L </span></span><span class="hljs-function"></span>&#123;p=l-&gt;next;<span class="hljs-comment">//记录原表第一个元素结点的地址 </span>l-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//从将头结点的next域置空得新空链表</span><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;q=p-&gt;next;<span class="hljs-comment">/*q 指针保留原链表当前处理结点的下一个结点*/</span>p-&gt;next=l-&gt;next;l-&gt;next=p;<span class="hljs-comment">/*p 指向下一个待插入的结点*/</span>p=q;<span class="hljs-comment">/*p 指向下一个待插入的结点*/</span>&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=4> 二进制数加一运算</td></tr></table><blockquote><p>建立一个带头结点的线性链表，用以存放输入的二进制数，链表中每个结点的<br>data 域存放一个二进制位。并在此链表上实现对二进制数加 1 的运算</p></blockquote><p>【问题分析】<br>①建链表：带二进制数可用带头结点的单链表存储，第一个结点存储二进制数的最高位，依次存储，最后一个结点存储二进制数的最低位。<br><strong>②二进制加法规则</strong>：实现二进制数加 1 运算，方向从低位往高位找到第一个值为 0 的位，把该位改成1，其后所有各位改成0<br><img src="https://img-blog.csdnimg.cn/20200315092153438.png" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200315092207164.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>③链表实现二进制加 1 时，从高位往低位与运算方向正好相反，从第一个结点开始找，找出最后一个值域为 0 的结点，把该结点值域赋为 1，其后所有结点的值域赋为 0。</p><p>④若在链表中未找到值域为 0 的结点，则表示该二进制数各位均为 1，此时，申请一新结点，值域为 1，插入到头结点与原链表的第一个结点之间，成为新链表的第一个结点，其后所有结点的值域赋为 0。</p><p>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">binadd</span><span class="hljs-params">(linklist l)</span> </span>&#123;node *q,*r,*s;q=l-&gt;next;r=l;<span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//找到最后一个值域为0的点</span>&#123;<span class="hljs-keyword">if</span>(q-&gt;data==<span class="hljs-number">0</span>) r=q;q=q-&gt;nest;&#125;<span class="hljs-keyword">if</span>(r!=l) <span class="hljs-comment">//能够找到值域为0的点</span>&#123;r-&gt;data=<span class="hljs-number">1</span>;<span class="hljs-comment">/*将最后一个值域为 0 的结点的值域赋为 1*/</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//该二进制数各位均为 1</span>&#123; s=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<span class="hljs-comment">/*申请新结点存放最高进位*/</span>s-&gt;data=<span class="hljs-number">1</span>;<span class="hljs-comment">/*值域赋为 1*/</span>s-&gt;next=l-&gt;nest;l-&gt;nest=s;<span class="hljs-comment">/*插入到头结点之后*/</span>r=s;&#125;r=r-&gt;nest;<span class="hljs-keyword">while</span>(r!=<span class="hljs-literal">NULL</span>) <span class="hljs-comment">/*将后面的所有结点的值域赋为 0*/</span>&#123; r-&gt;data=<span class="hljs-number">0</span>;r=r-&gt;nest;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
      <category>线性表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】顺序表及其基本运算和应用</title>
    <link href="/2020/03/01/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2020/03/01/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#99CCFF><font  size=5> 顺序存储结构的c语言描述</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100<span class="hljs-comment">/*此处的宏定义常量表示线性表可能达到的最大长度*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>ElemType elem[MAXSIZE];<span class="hljs-comment">/*线性表占用的数组空间*/</span><span class="hljs-keyword">int</span> last;<span class="hljs-comment">/*记录线性表中最后一个元素在数组elem[]中的位置（下标值），</span><span class="hljs-comment">空表置为-1*/</span> &#125;SeqList;</code></pre></div><blockquote><p>在C语言数据结构中，关于数据元素的类型定义均用“ ElemType e；”来表示，其中e是表示数据元素的变量，而ElemType则是它的类型，ElemType的含义就是“数据元素的类型”，是一个抽象的概念，是表示我们所要使用的数据元素应有的类型。<br>ElemType是数据结构上为了说明问题而用的一个词。它是element type（“元素的类型”）的简化体。因为数据结构是讨论抽象的数据结构和算法，一种结构中元素的类型不一定是整型、字符型、浮点型或者用户自定义类型，为了不重复说明，使用过程用 “elemtype” 代表所有可能的数据类型，简单明了的概括整体。<br>在算法中，除特别说明外，规定ElemType的默认是int型。</p></blockquote><table><tr><td bgcolor=#E6E6FA><font  size=6> 顺序表的基本运算</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=5> 一、按值查找</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Locate</span><span class="hljs-params">(SeqList L ,ElemType e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中依次存放着线性表中的元素，</span></span><span class="hljs-function"><span class="hljs-comment">在表中查找到与e相等的元素，</span></span><span class="hljs-function"><span class="hljs-comment">若L[i]=e则找到该元素，并返回i的数值</span></span><span class="hljs-function"><span class="hljs-comment">若找不到，则返回“-1”*/</span></span><span class="hljs-function"></span>&#123;i=<span class="hljs-number">0</span>;<span class="hljs-comment">/*i为扫描计数器，初始值为0，即从第一个元素开始比较*/</span><span class="hljs-keyword">while</span>((i&lt;L.last)&amp;&amp;(L.elem[i]!=e))&#123;i++;<span class="hljs-comment">/*顺序扫描表，直到找到值为e的元素或扫描到表尾而没找到*/</span>&#125; <span class="hljs-keyword">if</span>(i&lt;=L.last)<span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>);<span class="hljs-comment">/*若找到，则返回其序号*/</span> <span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<span class="hljs-comment">/*若没找到，则返回空序号*/</span>  &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 二、插入</td></tr></table><p><em>其实是移动部分的代码</em></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsList</span><span class="hljs-params">(SeqList *L,<span class="hljs-keyword">int</span> i,ElemType e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中第i个元素之前插入一个元素e</span></span><span class="hljs-function"><span class="hljs-comment">表长n=L-&gt;last+1，</span></span><span class="hljs-function"><span class="hljs-comment">i的合法取值范围是1&lt;=i&lt;=L&lt;last+2*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> k;<span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L-&gt;last+<span class="hljs-number">2</span>))<span class="hljs-comment">/*首先判断插入位置是否合法*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置i值不合法"</span>);<span class="hljs-keyword">return</span> (ERROR);&#125; <span class="hljs-keyword">if</span>(L-&gt;last&gt;=maxsize<span class="hljs-number">-1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"表已满无法插入"</span>);<span class="hljs-keyword">return</span> (ERROR);&#125;<span class="hljs-keyword">for</span>(k=L-&gt;last;k&gt;=i<span class="hljs-number">-1</span>;k--)<span class="hljs-comment">/*为插入元素而移动位置*/</span>&#123;L-&gt;elem[k+<span class="hljs-number">1</span>]=L-&gt;elem[k];&#125;L-&gt;elem[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">/*在c语言中，第i个元素的下标为i-1*/</span>L-&gt;last++;<span class="hljs-keyword">return</span> (OK); &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 三、删除</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Locate</span><span class="hljs-params">(SeqList *L ,<span class="hljs-keyword">int</span> i,ElemType *e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中删除第i个数据，并用指针参数e返回其值</span></span><span class="hljs-function"><span class="hljs-comment">i的合法取值为1&lt;=i&lt;=L.last+1*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> k;<span class="hljs-keyword">while</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L-&gt;last+<span class="hljs-number">1</span>)) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除位置不合法！"</span>);<span class="hljs-keyword">return</span>(error);&#125;*e=L-&gt;elem[i<span class="hljs-number">-1</span>]<span class="hljs-comment">/*将删除的元素存放到e所指的变量中*/</span><span class="hljs-keyword">for</span>(k=i; k&lt;=L-&gt;last; k++) &#123;L-&gt;elem[k<span class="hljs-number">-1</span>]=L-&gt;elem[k];<span class="hljs-comment">/*将后面的元素依次前移*/</span>L-&gt;last--;<span class="hljs-keyword">return</span> (ok);&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 四、有序表合并</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(SeqList *LA,SeqList *LB,SeqList *LC)</span> </span>&#123;<span class="hljs-keyword">int</span> i,j,k,l;i=<span class="hljs-number">0</span>;j=<span class="hljs-number">0</span>;k=<span class="hljs-number">0</span>;<span class="hljs-comment">/*LC 为空表,设LC表的指示器k=0.</span><span class="hljs-comment">设两个指示器 i,j 分别指向表 LA 和 LB 的当前位置，初值均为 0*/</span><span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last&amp;&amp;j&lt;=LB-&gt;last) &#123;<span class="hljs-keyword">if</span>(LA-&gt;elem[i]&lt;=LB-&gt;elem[j]) &#123;LC-&gt;elem[k]=LA-&gt;elem[i];i++;k++;&#125; <span class="hljs-keyword">else</span> &#123;LC-&gt;elem[k]=LB-&gt;elem[j];j++;k++;&#125;&#125;<span class="hljs-comment">/*：LA 表和 LB 表的当前元素比较，小的元素进 LC 表，且该表的指</span><span class="hljs-comment">示器和 LC 表的指示器 k 均加 1 移向下一个位置。如此下去，直到 LA 或 LB 表</span><span class="hljs-comment">中一个表处理完毕为止。*/</span><span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last) &#123; <span class="hljs-comment">/*当表LA比表LB长时，则将表LA余下的元素赋给表LC*/</span>LC-&gt;elem[k]=LA-&gt;elem[i];i++;k++;&#125;<span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last) &#123; <span class="hljs-comment">/*当表LB比表LA长时，则将表LB余下的元素赋给表LC*/</span>LC-&gt;elem[k]=LB-&gt;elem[j];j++;k++;&#125;LC-&gt;last=LA-&gt;last+LB-&gt;last+<span class="hljs-number">1</span>;&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6> 算法应用示例</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=4> 分解顺序表为奇偶两部分</td></tr></table><blockquote><p>已知顺序表 L 中的数据元素类型为 int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为 O(n)，空间复杂度为 O（1）。</p></blockquote><p>【问题分析】<br>初见此题，可能会想到额外申请 1 个顺序表空间，之后依次从顺序表 L 中选<br>择奇数放入新表前部分，选择偶数放在新表的后半部分。但是题目要求空间复杂度为 O(1),很显然上述方法是不可行的。既然要求空间复杂度为 O(1)，说明只能借助 1 个辅助空间。</p><p>分析题目要求，其实只需要将位于表左半部分的偶数与位于表右半部分的奇数通过一个辅助变量进行交换即可，为此可以设置两个位置指示器 i 和 j,i 初值为 0，j 初值为 L-&gt;last。<br>当L-&gt;elem[i]为偶数，L-&gt;elem[j]为奇数时，则将 L-&gt;elem[i] 与 L-&gt;elem[j]交换；否则，L-&gt;elem[i]为奇数,i++, L-&gt;elem[j]为偶数，j++。这样既可以保证算法的时间复杂度为 O(n),亦可保证空间复杂度为 O（1）。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c">adjustsqlist(seqlist *l)&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=l-&gt;last,t;<span class="hljs-keyword">while</span>(i&lt;j)&#123;<span class="hljs-keyword">while</span>(l-&gt;elem[i]%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<span class="hljs-comment">/*从表的左半部分开始检测，若为奇数，则 i 加 1,直到找到偶数为止*/</span>i++;<span class="hljs-keyword">while</span>(l-&gt;elem[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">/*从表的左半部分开始检测，若为偶数，则 j 减 1,直到找到奇数为止*/</span>j--;<span class="hljs-keyword">if</span>(i&lt;j)&#123;t=l-&gt;elem[i];l-&gt;elem[i]=l-&gt;elem[j];l-&gt;elem[j]=t;&#125; &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
      <category>线性表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>练习5-1 求m到n之和</title>
    <link href="/2019/10/29/%E7%BB%83%E4%B9%A05-1%20%E6%B1%82m%E5%88%B0n%E4%B9%8B%E5%92%8C/"/>
    <url>/2019/10/29/%E7%BB%83%E4%B9%A05-1%20%E6%B1%82m%E5%88%B0n%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>本题要求实现一个计算m~n（m&lt;n）之间所有整数的和的简单函数。<br>函数接口定义：</p><div class="hljs"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>( <span class="hljs-built_in">int</span> m, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> );</code></pre></div><p>其中m和n是用户传入的参数，保证有m&lt;n。函数返回的是m~n之间所有整数的和。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(m&lt;=n)&#123;sum = sum +m;m=m+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> m, n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;m, &amp;n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sum = %d\n"</span>, sum(m, n));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>入门训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PTA</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>练习5-2 找两个数中最大者</title>
    <link href="/2019/10/29/%E7%BB%83%E4%B9%A05-2%20%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%80%85/"/>
    <url>/2019/10/29/%E7%BB%83%E4%B9%A05-2%20%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%80%85/</url>
    
    <content type="html"><![CDATA[<p>本题要求对两个整数a和b，输出其中较大的数。<br>函数接口定义</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">( <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b )</span></span>;</code></pre></div><p>其中a和b是用户传入的参数，函数返回的是两者中较大的数</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">( <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b )</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>;<span class="hljs-keyword">if</span>(a&gt;b)&#123;<span class="hljs-built_in">max</span>=a;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">max</span>=b;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> a, b;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;a, &amp;b);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"max = %d\n"</span>, <span class="hljs-built_in">max</span>(a, b));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>入门训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PTA</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>练习5-3 数字金字塔</title>
    <link href="/2019/10/29/%E7%BB%83%E4%B9%A05-3%20%E6%95%B0%E5%AD%97%E9%87%91%E5%AD%97%E5%A1%94/"/>
    <url>/2019/10/29/%E7%BB%83%E4%B9%A05-3%20%E6%95%B0%E5%AD%97%E9%87%91%E5%AD%97%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<p>本题要求实现函数输出n行数字金字塔。<br>函数接口定义：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pyramid</span><span class="hljs-params">( <span class="hljs-keyword">int</span> n )</span></span>;</code></pre></div><p>其中n是用户传入的参数，为[1, 9]的正整数。<br>要求函数按照如样例所示的格式打印出n行数字金字塔。<br>注意每个数字后面跟一个空格</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pyramid</span><span class="hljs-params">( <span class="hljs-keyword">int</span> n )</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> c=n;<span class="hljs-keyword">for</span>(a=<span class="hljs-number">1</span>; a&lt;=n; a+=<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(c=n; a&lt;c<span class="hljs-number">-1</span>; c-=<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);&#125;<span class="hljs-keyword">if</span>(a==n) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a);<span class="hljs-keyword">for</span>(b=<span class="hljs-number">1</span>; a&gt;b; b+=<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a);<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,a);<span class="hljs-keyword">for</span>(b=<span class="hljs-number">1</span>; a&gt;b; b+=<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);    pyramid(n);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    system(<span class="hljs-string">"pause"</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>入门训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PTA</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
