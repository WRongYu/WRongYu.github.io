<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【蓝桥杯】10B省赛F特别数的和</title>
    <link href="/2020/07/01/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BF%E7%89%B9%E5%88%AB%E6%95%B0%E7%9A%84%E5%92%8C%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2020/07/01/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BF%E7%89%B9%E5%88%AB%E6%95%B0%E7%9A%84%E5%92%8C%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="试题-F-特别数的和"><a href="#试题-F-特别数的和" class="headerlink" title="试题 F: 特别数的和"></a>试题 F: 特别数的和</h1><p><img src="https://img-blog.csdnimg.cn/20200625225218571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>没啥算法，直接枚举加check即可</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (x)    &#123;        res = x % <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span> || res == <span class="hljs-number">1</span> || res == <span class="hljs-number">2</span> || res == <span class="hljs-number">9</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        x /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        <span class="hljs-keyword">if</span> (check(i))        &#123;            sum += i;        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>基础训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】10B省赛F特别数的和</title>
    <link href="/2020/06/25/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BF%E7%89%B9%E5%88%AB%E6%95%B0%E7%9A%84%E5%92%8C/"/>
    <url>/2020/06/25/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BF%E7%89%B9%E5%88%AB%E6%95%B0%E7%9A%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="试题-F-特别数的和"><a href="#试题-F-特别数的和" class="headerlink" title="试题 F: 特别数的和"></a>试题 F: 特别数的和</h1><p><img src="https://img-blog.csdnimg.cn/20200625225218571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>没啥算法，直接枚举加check即可</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (x)    &#123;        res = x % <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span> || res == <span class="hljs-number">1</span> || res == <span class="hljs-number">2</span> || res == <span class="hljs-number">9</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        x /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        <span class="hljs-keyword">if</span> (check(i))        &#123;            sum += i;        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>基础训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】10B省赛D:数的分解</title>
    <link href="/2020/06/23/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BD%E6%95%B0%E7%9A%84%E5%88%86%E8%A7%A3/"/>
    <url>/2020/06/23/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BD%E6%95%B0%E7%9A%84%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="试题-D-数的分解"><a href="#试题-D-数的分解" class="headerlink" title="试题 D: 数的分解"></a>试题 D: 数的分解<img src="https://img-blog.csdnimg.cn/20200623104502588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题目因为分解三个数然后不能重复，还有每个数不包含2,4。其实这道题目不用搜索，枚举就可以了，但是重复情况怎么考虑？<br>我们发现2019 = x + y + z<br>那么对于一组x,y,z三个数的位置不同也算一种那么，对于x,y,z三个位置相当于有6种摆放位置，我们只需要将枚举结果除以6即可得到答案。<br>因为是填空题，时间复杂度为2019^3，还是要跑个10几秒的<br>答案：40785</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">//判断三个正整数中是否含2或4</span>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (x)    &#123;        res = x % <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">2</span> || res == <span class="hljs-number">4</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        x /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">while</span> (y)    &#123;        res = y % <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">2</span> || res == <span class="hljs-number">4</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        y /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">while</span> (z)    &#123;        res = z % <span class="hljs-number">10</span>;        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">2</span> || res == <span class="hljs-number">4</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        z /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; a &lt; <span class="hljs-number">2019</span>; a++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>; b &lt; <span class="hljs-number">2019</span>; b++)        &#123;            <span class="hljs-keyword">if</span> (b == a)                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//a,b,c三个数不相同</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>; c &lt; <span class="hljs-number">2019</span>; c++)            &#123;                <span class="hljs-keyword">if</span> (b == c || a == c)                    <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span> (a + b + c == <span class="hljs-number">2019</span> &amp;&amp; check(a, b, c))                    ans++;            &#125;        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; ans / <span class="hljs-number">6</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="试题-E-迷宫"><a href="#试题-E-迷宫" class="headerlink" title="试题 E: 迷宫"></a>试题 E: 迷宫</h1><p><img src="https://img-blog.csdnimg.cn/20200623120401656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200623120422130.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>算法</category>
      
      <category>枚举</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】10B省赛E:迷宫</title>
    <link href="/2020/06/23/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BE%E8%BF%B7%E5%AE%AB/"/>
    <url>/2020/06/23/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BE%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="试题-E-迷宫"><a href="#试题-E-迷宫" class="headerlink" title="试题 E: 迷宫"></a>试题 E: 迷宫</h1><p><img src="https://img-blog.csdnimg.cn/20200623120401656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200623120422130.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实这道题目看到==最短路==，最容易想到==BFS（广搜）==。<br>但是这道题目不是要你求最短路长度而是求出最短路的路径，提交一个字符串，其实别想差，最简单的就是将方向数组的每一步上，下，左，右，和D,U,L,R相对应，只需要在结构体中添加一个字符串记录即可。<br>方向数组的顺序要按照字典序从小到大的顺序D,L,R,U来跑。</p><p>ps：本来想试着文件输入迷宫地图，但是发现文件的输入不支持二维数组，一维数组倒是可以。<br>并且本题不用文件输入更好做，因为循环输入是按照行来输的，末端换行自动当分隔符。这个写代码的人太厉害了！</p><p>答案：DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">30</span>][<span class="hljs-number">50</span>]; <span class="hljs-comment">//地图</span><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">30</span>][<span class="hljs-number">50</span>]; <span class="hljs-comment">//标记该点是否走过</span><span class="hljs-keyword">int</span> n, m;         <span class="hljs-comment">//迷宫的行，列</span><span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">//方向数组按照下，左，右，上的顺序走</span><span class="hljs-keyword">char</span> dirc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">'D'</span>,<span class="hljs-string">'L'</span>,<span class="hljs-string">'R'</span>,<span class="hljs-string">'U'</span>&#125;;<span class="hljs-comment">//判断是否越界，是否撞墙，是否访问过了</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= m || <span class="hljs-built_in">map</span>[x][y] == <span class="hljs-string">'1'</span> || vis[x][y])&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x; <span class="hljs-comment">//横坐标</span>    <span class="hljs-keyword">int</span> y; <span class="hljs-comment">//纵坐标</span>    <span class="hljs-keyword">int</span> step; <span class="hljs-comment">//步数</span>    <span class="hljs-built_in">string</span> str; <span class="hljs-comment">//路径</span>    <span class="hljs-comment">//构造函数</span>    node(<span class="hljs-keyword">int</span> xx, <span class="hljs-keyword">int</span> yy, <span class="hljs-keyword">int</span> ss, <span class="hljs-built_in">string</span> s)&#123;        x = xx;        y = yy;        step = ss;        str = s;    &#125;&#125;;<span class="hljs-built_in">queue</span>&lt;node&gt; q; <span class="hljs-comment">//创建队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;    q.push(node(x, y, <span class="hljs-number">0</span>, <span class="hljs-string">""</span>));    vis[x][y] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">while</span> (!q.empty())    &#123;        node now = q.front();        <span class="hljs-comment">//到达终点了</span>        <span class="hljs-keyword">if</span> (now.x == n - <span class="hljs-number">1</span> &amp;&amp; now.y == m - <span class="hljs-number">1</span>)&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; now.str &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">cout</span> &lt;&lt; now.step &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        &#125;        q.pop();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;            <span class="hljs-keyword">int</span> nx = now.x + dir[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> ny = now.y + dir[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (check(nx, ny))            &#123;                q.push(node(nx, ny, now.step + <span class="hljs-number">1</span>, now.str + dirc[i]));                vis[nx][ny] = <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;   &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, <span class="hljs-built_in">map</span>[i]);    &#125;    bfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><blockquote><p>便于复制<br>01010101001011001001010110010110100100001000101010<br>00001000100000101010010000100000001001100110100101<br>01111011010010001000001101001011100011000000010000<br>01000000001010100011010000101000001010101011001011<br>00011111000000101000010010100010100000101100000000<br>11001000110101000010101100011010011010101011110111<br>00011011010101001001001010000001000101001110000000<br>10100000101000100110101010111110011000010000111010<br>00111000001010100001100010000001000101001100001001<br>11000110100001110010001001010101010101010001101000<br>00010000100100000101001010101110100010101010000101<br>11100100101001001000010000010101010100100100010100<br>00000010000000101011001111010001100000101010100011<br>10101010011100001000011000010110011110110100001000<br>10101010100001101010100101000010100000111011101001<br>10000000101100010000101100101101001011100000000100<br>10101001000000010100100001000100000100011110101001<br>00101001010101101001010100011010101101110000110101<br>11001010000100001100000010100101000001000111000010<br>00001000110000110101101000000100101001001000011101<br>10100101000101000000001110110010110101101010100001<br>00101000010000110101010000100010001001000100010101<br>10100001000110010001000010101001010101011111010010<br>00000100101000000110010100101001000001000000000010<br>11010000001001110111001001000011101001011011101000<br>00000110100010001000100000001000011101000000110011<br>10101000101000100010001111100010101001010000001000<br>10000010100101001010110000000100101010001011101000<br>00111100001000010000000110111000000001000000001011<br>10000001100111010111010001000110111010101101111000</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>基础训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】10B省赛C:数列求值</title>
    <link href="/2020/06/23/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BC%E6%95%B0%E5%88%97%E6%B1%82%E5%80%BC/"/>
    <url>/2020/06/23/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BC%E6%95%B0%E5%88%97%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="试题-C-数列求值"><a href="#试题-C-数列求值" class="headerlink" title="试题 C: 数列求值"></a>试题 C: 数列求值</h1><p><img src="https://img-blog.csdnimg.cn/20200622223345882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题目其实就是一道斐波那契数列变形，而且题目直接告诉你从第四项开始每一项等于前三项的和直接可以写出递推式。但是这么大的数肯定超出long long 了，对每一步mod10000即可得到正确答案</p><h2 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> a1 = <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> a2 = <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> a3 = <span class="hljs-number">1</span>;   <span class="hljs-keyword">int</span> a4 = <span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= <span class="hljs-number">20190324</span>; i++)   &#123;      a4 = (a1 + a2 + a3) % <span class="hljs-number">10000</span>;      a1 = a2;      a2 = a3;      a3 = a4;   &#125;   <span class="hljs-built_in">cout</span> &lt;&lt; a4;&#125;</code></pre></div><p>4659</p><h2 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e4</span>;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[<span class="hljs-number">20190325</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>] = dp[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= <span class="hljs-number">20190324</span>; i++)   &#123;      dp[i] = (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>] + dp[i - <span class="hljs-number">3</span>]) % mod;   &#125;   <span class="hljs-built_in">cout</span> &lt;&lt; dp[<span class="hljs-number">20190324</span>];   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>算法</category>
      
      <category>递归</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】10B省赛B:年号字串</title>
    <link href="/2020/06/22/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BB%E5%B9%B4%E5%8F%B7%E5%AD%97%E4%B8%B2/"/>
    <url>/2020/06/22/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%9110B%E7%9C%81%E8%B5%9BB%E5%B9%B4%E5%8F%B7%E5%AD%97%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="试题-B-年号字串"><a href="#试题-B-年号字串" class="headerlink" title="试题 B: 年号字串"></a>试题 B: 年号字串</h1><p><img src="https://img-blog.csdnimg.cn/20200622202256318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h2><p>这道题目实际就是一个将十进制转换为26进制，分析题目给的数据<br>A——1<br>1 * 26^0 = 1<br>Z——26<br>26 * 26^0 = 26<br>AA——27<br>1 * 26^1 + 1 * 26^0 = 26 + 1 = 7<br>AB——28<br>1 * 26^1 + 2 * 26^0 = 26 + 2 = 28<br>AZ——52<br>1 * 26^1 + 26 * 26^0 = 26 + 26 = 52<br>LQ——329<br>12 * 26^1 + 17 * 26^0 = 312 + 17 = 329<br>这样就可以推出来是10进制转换26进制了<br>然后我们模拟将十进制转换为26进制即可，使用短除法，在逆序输出字符串即可。//可以直接手算</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;//这个头文件有些oj不支持</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> str[<span class="hljs-number">27</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'F'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'H'</span>,<span class="hljs-string">'I'</span>,<span class="hljs-string">'J'</span>,<span class="hljs-string">'K'</span>   ,<span class="hljs-string">'L'</span>,<span class="hljs-string">'M'</span>,<span class="hljs-string">'N'</span>,<span class="hljs-string">'O'</span>,<span class="hljs-string">'P'</span>,<span class="hljs-string">'Q'</span>,<span class="hljs-string">'R'</span>,<span class="hljs-string">'S'</span>,<span class="hljs-string">'T'</span>,<span class="hljs-string">'U'</span>,<span class="hljs-string">'V'</span>,   <span class="hljs-string">'W'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'Y'</span>,<span class="hljs-string">'Z'</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">int</span> num;   <span class="hljs-built_in">string</span> ans = <span class="hljs-string">""</span>;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num);   <span class="hljs-keyword">while</span>(num) &#123;   ans += str[num % <span class="hljs-number">26</span>];   num /= <span class="hljs-number">26</span>;   &#125;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;   <span class="hljs-built_in">cout</span> &lt;&lt; ans[i];   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h2><p>首先要新建一个excel表格。<br><img src="https://img-blog.csdnimg.cn/2020062220545566.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在A1、A2、A3分别输入1、2、3，接着使用自动自动填充功能，将数字填充到2019以后即可。<br><img src="https://img-blog.csdnimg.cn/20200622205504216.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>基础训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【查找】基于线性表的查找法</title>
    <link href="/2020/06/17/%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91%E5%9F%BA%E4%BA%8E%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <url>/2020/06/17/%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91%E5%9F%BA%E4%BA%8E%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6> 查找的主要方法</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200617180500107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=6>基于线性表的查找法</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=5> 一、顺序查找法</td></tr></table><blockquote><p>顺序查找法的特点是，用所给关键字与线性表中各元素的关键字逐个比较，直到成功或失败。存储结构通常为顺序结构，也可为链式结构。</p></blockquote><p>顺序结构数据类型的定义：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_SIZE 20</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>KeyType key;OtherType other_data;&#125; RecordType;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>RecordType r[LIST_SIZE+<span class="hljs-number">1</span>]; <span class="hljs-comment">/* r[0]为工作单元 */</span><span class="hljs-keyword">int</span> length;&#125; RecordList;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>[算法思想] </td></tr></table><p>在表的一端设置一个称为“监视哨”的附加单元，存放要查找元素的关键字。从表的另一端开始查找，如果在“监视哨”找到要查找元素的关键字，返回失败信息，否则返回相应下标。</p><table><tr><td bgcolor=#99CCFF><font  size=5>[算法描述-设置监视哨的顺序查找法] </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> SeqSearch（RecordList l, KeyType k）<span class="hljs-comment">/*在顺序表 l 中顺序查找其关键字等于 k</span><span class="hljs-comment">   的元素，若找到，则函数值为该元素在表中的位置，否则为 0*/</span>&#123;  l.r[<span class="hljs-number">0</span>].key = k; <span class="hljs-comment">//其中 l.r[0] 为“监视哨”，可以起到防止越界的作用。</span>  i = l.length;  <span class="hljs-keyword">while</span> (l.r[i].key != k)    i--;  <span class="hljs-keyword">return</span>(i);&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>[算法分析] </td></tr></table><p>用平均查找长度（ASL）分析顺序查找算法的性能。假设列表长度为 n，那么查找第 i个数据元素时需进行 n-i+1 次比较，即 Ci=n-i+1。又假设查找每个数据元素的概率相等，即 Pi=1/n，则顺序查找算法的平均查找长度为：<br><img src="https://img-blog.csdnimg.cn/20200617181323368.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>为便于比较，下面给出不用“监视哨”的算法</p><table><tr><td bgcolor=#99CCFF><font  size=5>[算法描述-不设置监视哨的顺序查找法] </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SeqSearch</span><span class="hljs-params">(RecordList l, KeyType k)</span></span><span class="hljs-function"><span class="hljs-comment">/*不用“监视哨”法，在顺序表中查找关键字等于 k 的元素*/</span></span><span class="hljs-function"></span>&#123;  i = l.length;  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; l.r[i].key != k)    i--;  <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> (i) <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);&#125;</code></pre></div><blockquote><p>算法 2 与算法 1 相比，循环控制条件中增加了 i&gt;=1，用以判断查找过程是否越界。加 上“监视哨”可省去这个条件，从而提高查找效率。</p></blockquote><table><tr><td bgcolor=#FFC0CB><font  size=5> 二、折半（二分）查找法</td></tr></table><blockquote><p>折半查找法又称为==二分查找法==，这种方法对待查找的列表有两个要求：<br>（1）必须采用顺序存储结构；（2）必须按关键字大小有序排列。</p></blockquote><table><tr><td bgcolor=#99CCFF><font  size=5>[算法思想] </td></tr></table><p>首先，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；<br>否则利用中间位置记录将表分成前、后两个子表。<br>如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。<br>重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><p>下图给出了用折半查找法查找 12、50 的具体过程，其中 mid=(low+high)/2，当 high&lt;low 时，表示不存在这样的子表空间，查找失败<br><img src="https://img-blog.csdnimg.cn/2020061719005599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200617190041928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#99CCFF><font  size=5>[算法描述-折半查找法] </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> BinSrch （RecordList l, KeyType k）<span class="hljs-comment">/*在有序表 l 中折半查找其关键字等于 k 的元素，若找到，则函数值为该元素在表中的</span><span class="hljs-comment">位置*/</span>&#123;  low = <span class="hljs-number">1</span>;  high = l.length; <span class="hljs-comment">/*置区间初值*/</span>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;    mid = (low + high) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (k == l.r[mid].key)      <span class="hljs-keyword">return</span>（mid）; <span class="hljs-comment">/*找到待查元素*/</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; l.r[mid].key)      high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">/*未找到，则继续在前半区间进行查找*/</span>    <span class="hljs-keyword">else</span>      low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">/*继续在后半区间进行查找*/</span>  &#125;  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>[算法分析] </td></tr></table>ppt里 略<table><tr><td bgcolor=#FFC0CB><font  size=5>三、 分块查找法</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200617191330525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【队列】队列的应用举例</title>
    <link href="/2020/06/17/%E3%80%90%E9%98%9F%E5%88%97%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/"/>
    <url>/2020/06/17/%E3%80%90%E9%98%9F%E5%88%97%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=5> 1．打印杨辉三角 </td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200507122903985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200507123635286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200507123022339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>注意：所打印的杨辉三角形的最大行数一定要小于循环队列的 MAXSIZE 值。当然，本例用链队列也完全可以实现。<br>【算法描述】  </p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YangHuiTriangle</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    SeqQueue Q;    InitQueue(&amp;Q);           <span class="hljs-comment">/* 初始化*/</span>    EnterQueue(&amp;Q, <span class="hljs-number">1</span>);       <span class="hljs-comment">/* 第一行元素入队*/</span>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">2</span>; n &lt;= N; n++) <span class="hljs-comment">/* 产生第 n 行元素并入队，同时打印第 n-1 行的元素*/</span>    &#123;        EnterQueue(&amp;Q, <span class="hljs-number">1</span>);           <span class="hljs-comment">/* 第 n 行的第一个元素入队*/</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">2</span>; i++) <span class="hljs-comment">/* 利用队中第 n-1 行元素产生第 n 行的中间 n-2 个元素 并入队*/</span>        &#123;            DeleteQueue(&amp;Q, &amp;temp);            Printf(“% d”, temp); <span class="hljs-comment">/* 打印第 n-1 行的元素*/</span>            GetHead(Q, &amp;x);            temp = temp + x; <span class="hljs-comment">/*利用队中第 n-1 行元素产生第 n 行元素*/</span>            EnterQueue(&amp;Q, temp);        &#125;        DeleteQueue(&amp;Q, &amp;x);        <span class="hljs-built_in">printf</span>(“% d”, x); <span class="hljs-comment">/* 打印第 n-1 行的最后一个元素 */</span>        EnterQueue(&amp;Q, <span class="hljs-number">1</span>) <span class="hljs-comment">/* 第 n 行的最后一个元素入队 */</span>    &#125;    <span class="hljs-keyword">while</span> (!IsEmpty(Q)) <span class="hljs-comment">/* 打印最后一行元素 */</span>    &#123;        DeleteQueue(&amp;Q, &amp;x);        <span class="hljs-built_in">printf</span>(“% d”, x);    &#125;&#125;</code></pre></div><p>上面的算法只是逐个打印出了杨辉三角形前 N 层中的数据元素，并没有按三角形的形式输出，读者可以自己加入坐标数据，然后在屏幕上打印出杨辉三角形。 </p><table><tr><td bgcolor=#E6E6FA><font  size=5> 2．键盘输入循环缓冲区问题 </td></tr></table><blockquote><p>在操作系统中，循环队列经常用于实时应用程序。例如，当程序正在执行其他任务时，用户 可以从键盘上不断键入所要输入的内容。系统在利用这种分时处理方法时，用户键入的内容 不能在屏幕上立刻显示出来，直到当前正在工作的那个进程结束为止。但在这个进程执行时， 系统是在不断地检查键盘状态，如果检测到用户键入了一个新的字符，就立刻把它存到系统 缓冲区中，然后继续运行原来的进程。当当前工作的进程结束后，系统就从缓冲区中取出键入的字符，并按要求进行处理。这里的键盘输入缓冲区采用了循环队列。队列的特性保证了 输入字符先键入、先保存、先处理的要求，循环结构又有效地限制了缓冲区的大小，并避免了假溢出问题。</p></blockquote><p>【问题描述】<br>有两个进程同时存在于一个程序中。其中第一个进程在屏幕上连续显示字符 “A”，与此同时，程序不断检测键盘是否有输入，如果有的话，就读入用户键入的字符并 保存到输入缓冲区中。<br>在用户输入时，键入的字符并不立即回显在屏幕上。当用户键入一个 逗号（，）或分号(;)时，表示第一个进程结束，第二个进程从缓冲区中读取那些已键入的字符并显示在屏幕上。<br>第二个进程结束后，程序又进入第一个进程，重新显示字符“A”，同时用户又可以继续键入字符，直到用户输入一个分号（；）键，才结束第一个进程，同时也结束整个程序。 </p><p>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>main()&#123; <span class="hljs-comment">/*模拟键盘输入循环缓冲区*/</span>    <span class="hljs-keyword">char</span> ch1, ch2;    SeqQueue Q;    <span class="hljs-keyword">int</span> f;    InitQueue(&amp;Q); <span class="hljs-comment">/* 队列初始化 */</span>    <span class="hljs-keyword">for</span> (;;)    &#123;        <span class="hljs-keyword">for</span> (;;) <span class="hljs-comment">/*第一个进程*/</span>        &#123;            <span class="hljs-built_in">printf</span>(“A”);            <span class="hljs-keyword">if</span> (kbhit())            &#123;                ch1 = getch(); <span class="hljs-comment">/* 读取键入的字符，但屏幕上不显示 */</span>                <span class="hljs-keyword">if</span> (ch1 ==’;’|| ch1 ==’,’)                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 第一个进程正常中断 */</span>                f = EnterQueue(&amp;Q, ch1);                <span class="hljs-keyword">if</span> (f == FALSE)                &#123;                    <span class="hljs-built_in">printf</span>(“循环队列已满\n”);                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 循环队列满时，强制中断第一个进程*/</span>                &#125;            &#125;        &#125;        <span class="hljs-keyword">while</span> (!IsEmpty(Q)) <span class="hljs-comment">/*第二个进程*/</span>        &#123;            DeleteQueue(&amp;Q, &amp;ch2);            <span class="hljs-built_in">putchar</span>(ch2); <span class="hljs-comment">/*显示输入缓冲区的内容*/</span>        &#125;        <span class="hljs-keyword">if</span> (ch1 ==’.’)            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/*整个程序结束*/</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【队列】队列的顺序存储（循环队列）</title>
    <link href="/2020/06/17/%E3%80%90%E9%98%9F%E5%88%97%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%89/"/>
    <url>/2020/06/17/%E3%80%90%E9%98%9F%E5%88%97%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#FFC0CB><font  size=5>顺序队列的假溢出现象</td></tr></table><p><img src="https://img-blog.csdnimg.cn/2020050711550127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>循环队列的定义</td></tr></table><blockquote><p>为了解决假溢出现象并使得队列空间得到充分利用，一个较巧妙的办法是将顺序队列的数组看成一个环状的空间，即规定最后一个单元的后继为第一个单元，我们形象地称之为循环队列。</p></blockquote><ul><li>假设队列数组为 Queue[MAXSIZE]，当 rear+1=MAXSIZE 时，令 rear=0，即可求得最后一个单元 Queue[MAXSIZE-1]的后继：Queue[0]。</li><li>更简便的办法是通过数学中的取模（求余）运算来实现：rear=（rear+1）mod MAXSIZE，显然，当 rear+1=MAXSIZE 时，rear=0， 同样可求得最后一个单元 Queue[MAXSIZE-1]的后继：Queue[0]。</li><li>所以，借助于取模（求余） 运算，可以自动实现队尾指针、队头指针的循环变化。<br>进队操作时，队尾指针的变化是：rear= （rear+1）mod MAXSIZE ；<br>而出队操作时，队头指针的变化是：front=（front+1）mod MAXSIZE。 下图给出了循环队列的几种情况。 </li></ul><p><img src="https://img-blog.csdnimg.cn/20200507121115267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>循环队列判空判满</td></tr></table><blockquote><p> 与一般的非空顺序队列相同，在非空循环队列中，队头指针始终指向当前的队头元素，而队尾指针始终指向真正队尾元素后面的单元。<br>在下图 (c)所示 循环队列中，队列头元素 是 e3，队列尾元素是 e5，当 e6、e7和 e8相继入队后，队列空间均被占满，如上图 (b)所示， 此时队尾指针追上队头指针，所以有：front =rear。<br>反之，若 e3、e4 和 e5相继从上图 (c)的 队列中删除，则得到空队列，如上图 (a)所示，此时队头指针追上队尾指针，所以也存在关 系式：front = rear。<br>可见，只凭 front = rear 无法判别队列的状态是“空”还是“满”。</p></blockquote><ul><li>对于这个问题，可有两种处理方法：一种方法是少用一个元素空间。当队尾指针所指向的空单元 的后继单元是队头元素所在的单元时，则停止入队。这样一来，队尾指针永远追不上队头指针，所以队满时不会有 front =rear。</li><li>判队“满”的条件<strong>为（rear+1）mod MAXSIZE=front</strong></li><li>判队空的条件，<strong>仍为 rear=front</strong><br>另一种是增设一个标志量 tag的方法，以区别队列是“空” 还是“满”。初始化操作即产生一个空的循环队列，此时 Q-&gt;front = Q-&gt;rear=0，tag=0；当空的循环队列中有第一个元素入队时，则 tag=1，表示循环队列非空；当 tag=1 且 Q-&gt;front=Q-&gt;rear 时，表示队满。<br><img src="https://img-blog.csdnimg.cn/20200507121643881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><table><tr><td bgcolor=#FFC0CB><font  size=5>循环队列的类型定义</td></tr><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 50 <span class="hljs-comment">/*队列的最大长度*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    QueueElementType element[MAXSIZE]; <span class="hljs-comment">/* 队列的元素空间*/</span>    <span class="hljs-keyword">int</span> front;                         <span class="hljs-comment">/*头指针指示器*/</span>    <span class="hljs-keyword">int</span> rear;                          <span class="hljs-comment">/*尾指针指示器*/</span>&#125; SeqQueue;</code></pre></div></table><table><tr><td bgcolor=#FFC0CB><font  size=5>循环队列的基本操作</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4> 1. 初始化操作</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> InitQueue（SeqQueue *Q）&#123; <span class="hljs-comment">/* 将*Q 初始化为一个空的循环队列 */</span>    Q-&gt;front = Q-&gt;rear = <span class="hljs-number">0</span>;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4> 2. 入队操作</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EnterQueue</span><span class="hljs-params">(SeqQueue *Q, QueueElementType x)</span></span><span class="hljs-function"></span>&#123;                                            <span class="hljs-comment">/*将元素 x 入队*/</span>    <span class="hljs-keyword">if</span> ((Q-&gt;rear + <span class="hljs-number">1</span>) % MAXSIZE == Q-&gt;front) <span class="hljs-comment">/*队列已经满了*/</span>        <span class="hljs-keyword">return</span> (FALSE);    Q-&gt;element[Q-&gt;rear] = x;    Q-&gt;rear = (Q-&gt;rear + <span class="hljs-number">1</span>) % MAXSIZE; <span class="hljs-comment">/* 重新设置队尾指针 */</span>    <span class="hljs-keyword">return</span> (TRUE);                     <span class="hljs-comment">/*操作成功*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4> 3. 出队操作</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeleteQueue</span><span class="hljs-params">(SeqQueue *Q, QueueElementType *x)</span></span><span class="hljs-function"></span>&#123;                             <span class="hljs-comment">/*删除队列的队头元素，用 x 返回其值*/</span>    <span class="hljs-keyword">if</span>（Q-&gt;front == Q-&gt;rear） <span class="hljs-comment">/*队列为空*/</span>    <span class="hljs-keyword">return</span> (FALSE);    *x = Q-&gt;element[Q-&gt;front];    Q-&gt;front = (Q-&gt;front + <span class="hljs-number">1</span>) % MAXSIZE; <span class="hljs-comment">/*重新设置队头指针*/</span>    <span class="hljs-keyword">return</span> (TRUE);                       <span class="hljs-comment">/*操作成功*/</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【队列】队列的链式存储</title>
    <link href="/2020/06/17/%E3%80%90%E9%98%9F%E5%88%97%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <url>/2020/06/17/%E3%80%90%E9%98%9F%E5%88%97%E3%80%91%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=5> 队列的定义</td></tr></table><p>队列是另一种限定性的线性表，它只允许在表的一端插入元素，而 在另一端删除元素，所以队列具有先进先出 (Fist In Fist Out，缩写为 FIFO)的特性。<br>在队列中，允许<strong>插入</strong>的一端叫做<strong>队尾</strong>(rear)。<br>允许<strong>删除</strong>的一端则称为<strong>队头</strong>(front)。<br><img src="https://img-blog.csdnimg.cn/20200506101847419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200506102214590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200506102217851.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>链队列的存储结构</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><span class="hljs-class">&#123;</span>    QueueElementType data; <span class="hljs-comment">/*数据域*/</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">/*指针域*/</span>&#125; LinkQueueNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    LinkQueueNode *front;    LinkQueueNode *rear;&#125; LinkQueue;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5>链队列的基本操作 </td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4> 1. 初始化操作</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue *Q)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 将 Q 初始化为一个空的链队列 */</span>    Q-&gt;front = (LinkQueueNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkQueueNode));    <span class="hljs-keyword">if</span> (Q-&gt;front != <span class="hljs-literal">NULL</span>)    &#123;        Q-&gt;rear = Q-&gt;front;        Q-&gt;front-&gt;next = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">return</span> (TRUE);    &#125;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> (FALSE); <span class="hljs-comment">/* 溢出！*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4> 2. 入队操作</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EnterQueue</span><span class="hljs-params">(LinkQueue *Q, QueueElementType x)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 将数据元素 x 插入到队列 Q 中 */</span>    LinkQueueNode *NewNode;    NewNode = (LinkQueueNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkQueueNode));    <span class="hljs-keyword">if</span> (NewNode != <span class="hljs-literal">NULL</span>)    &#123;        NewNode-&gt;data = x;        NewNode-&gt;next = <span class="hljs-literal">NULL</span>;        Q-&gt;rear-&gt;next = NewNode;        Q-&gt;rear = NewNode;        <span class="hljs-keyword">return</span> (TRUE);    &#125;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> (FALSE); <span class="hljs-comment">/* 溢出！*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4> 3. 出队操作</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeleteQueue</span><span class="hljs-params">(LinkQueue *Q, QueueElementType *x)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 将队列 Q 的队头元素出队，并存放到 x 所指的存储空间中 */</span>    LinkQueueNode *p;    <span class="hljs-keyword">if</span> (Q-&gt;front == Q-&gt;rear)        <span class="hljs-keyword">return</span> (FALSE);    p = Q-&gt;front-&gt;next;    Q-&gt;front-&gt;next = p-&gt;next; <span class="hljs-comment">/* 队头元素 p 出队 */</span>    <span class="hljs-keyword">if</span> (Q-&gt;rear == p)         <span class="hljs-comment">/* 如果队中只有一个元素 p，则 p 出队后成为空队 */</span>        Q-&gt;rear = Q-&gt;front;    *x = p-&gt;data;    <span class="hljs-built_in">free</span>(p); <span class="hljs-comment">/* 释放存储空间 */</span>    <span class="hljs-keyword">return</span> (TRUE);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】哈夫曼树及其构造</title>
    <link href="/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E6%9E%84%E9%80%A0/"/>
    <url>/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#EED2EE><font  size=6> 1．哈夫曼树的基本概念</td></tr></table><ol><li>结点间的<strong>路径</strong>和<strong>路径长度</strong><br>路径是指从一个结点到另一个结点之间的分支序列。<br>路径长度是指从一个结点到另一个结点所经过的分支数目。 </li><li>结点的<strong>权</strong>和<strong>带权路径长度</strong><br>在实际的应用中，==给树的每个结点赋予一个具有某种实际意义的实数，称该实数为这个结点的权==。<br>在树型结构中，把从树根到某一结点的路径长度与该结点的权的乘积，叫做该结点的带权路径长度。</li><li><strong>树的带权路径长度</strong><br>树的带权路径长度为树中从根到所有叶子结点的各个带权路径长度之和，通常记为：</li></ol><p><img src="https://img-blog.csdnimg.cn/20200326162907333.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200326163052734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200326163921943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200326163928446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200326163932831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#EED2EE><font  size=6> 2. 构造哈夫曼树</td></tr></table><p>哈夫曼树：它是==由 n 个带权叶子结点构成的所有二叉树中带权路径长度最短的二叉树==。因为这种树最早由哈夫曼（Huffman）研究，所以称为哈夫曼树，又叫<strong>最优二叉树</strong>。</p><ul><li>构造哈夫曼树的算法步骤如下：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200326164133803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200326164326368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>直观地看，先选择权小的，所以权小的结点被放置在树的较深层，而权较大的离根较近，这样自然在哈夫曼树中权越大叶子离根越近，这样一来，在计算树的带权路径长度时，自然会具有最小带权路径长度，这种生成算法就是一种典型的贪心法。</p></blockquote><table><tr><td bgcolor=#EED2EE><font  size=6> 3. 哈夫曼树的类型定义</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200326164652777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>（2）哈夫曼树的类型定义<br>用静态三叉链表实现的哈夫曼树类型定义如下：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 20        <span class="hljs-comment">/* 叶子结点的最大值。*/</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 2 * N - 1 <span class="hljs-comment">/* 所有结点的最大值。*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">int</span> weight;                 <span class="hljs-comment">/* 结点的权值*/</span>  <span class="hljs-keyword">int</span> parent;                 <span class="hljs-comment">/* 双亲的下标*/</span>  <span class="hljs-keyword">int</span> LChild;                 <span class="hljs-comment">/* 左孩子结点的下标*/</span>  <span class="hljs-keyword">int</span> RChild;                 <span class="hljs-comment">/* 右孩子结点的下标*/</span>&#125; HTNode, HuffmanTree[M + <span class="hljs-number">1</span>]; <span class="hljs-comment">/* HuffmanTree 是一个结构数组类型，0 号单元不 用。 */</span></code></pre></div><table><tr><td bgcolor=#EED2EE><font  size=6> 4．哈夫曼树的算法实现</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CrtHuffmanTree</span><span class="hljs-params">(HuffmanTree ht, <span class="hljs-keyword">int</span> w[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">/*构造哈夫曼树 ht[M+1]， w[ ]存放 n 个权值。*/</span>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)    ht[i] = &#123;w[i], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">/* 1 ~ n 号单元存放叶子结点，初始化*/</span>  m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (i = n + <span class="hljs-number">1</span>; i &lt;= m; i++)    ht[i] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">/* n+1 ~ m 号单元存放非叶结点，初始化 */</span>  <span class="hljs-comment">/*————————————初始化完毕！对应算法步骤 1—————————*/</span>  <span class="hljs-keyword">for</span> (i = n + <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-comment">/*创建非叶结点，建哈夫曼树*/</span>  &#123;    select(ht, i - <span class="hljs-number">1</span>, s1, s2); <span class="hljs-comment">/* 在 ht[1] ~ ht[i-1] 的范围内选择两个 parent 为 0 且</span><span class="hljs-comment">weight 最小的结点，其序号分别赋值给 s1、s2 返回 */</span>    ht[i].weight = ht[s1].weight + ht[s2].weight;    ht[s1].parent = i;    ht[s2].parent = i;    ht[i].LChild = s1;    ht[i].RChild = s2;  &#125; <span class="hljs-comment">/*哈夫曼树建立完毕*/</span>&#125;</code></pre></div><blockquote><p>该算法分成两大部分，其中第一部分是初始化，先初始化 ht 的前 1<del>n 号元素，存放叶子结点（相当初始森林），它们都没有双亲与孩子。再初始化 ht 的后 n-1 个（从 n+1</del>2n-1）非叶结点元素；第二部分为实施选择、删除合并 n-1 次（相当步骤（2）~（4））：选择是从当前森林中（在森林中树的根结点的双亲为 0）选择两棵根的权值最小的树；删除合并是将选到的两棵树的根权和存入 ht 的当前最前面的空闲元素中（相当于合并树中新结点），并置入相应的双亲与孩子的位置指示。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200326165254185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200326165257724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】树、森林和二叉树的关系</title>
    <link href="/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6>树的存储结构</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4>1.双亲表示法</td></tr></table><ul><li>这种方法用一组连续的空间来存储树中的结点，在保存每个结点的同时附设一个指示器来指示其双亲结点在表中的位置，其结点的结构如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200326140135686.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>双亲表示法的形式说明如下：</p></blockquote><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span></span><span class="hljs-class">&#123;</span>  DataType data;  <span class="hljs-keyword">int</span> parent;&#125; TNode;</code></pre></div><blockquote><p>树可以定义为：</p></blockquote><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  TNode tree[MAX];  <span class="hljs-keyword">int</span> nodenum; <span class="hljs-comment">/*结点数*/</span>&#125; ParentTree;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200326140352734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200326140601891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#99CCFF><font  size=4>2.孩子表示法</td></tr></table><ul><li>这种方法通常是把每个结点的孩子结点排列起来，构成一个单链表，称为孩子链表。n 个结点共有 n 个孩子链表（叶子结点的孩子链表为空表），而 n 个结点的数据和 n 个孩子链表的头指针又组成一个顺序表。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200326140921717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>孩子表示法的存储结构定义如下：</p></blockquote><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChildNode</span> /* 孩子链表结点的定义 */</span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">int</span> Child;              <span class="hljs-comment">/* 该孩子结点在线性表中的位置 */</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ChildNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">/*指向下一个孩子结点的指针 */</span>&#125; ChildNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /* 顺序表结点的结构定义 */</span><span class="hljs-class">&#123;</span>  DataType data;         <span class="hljs-comment">/* 结点的信息 */</span>  ChildNode *FirstChild; <span class="hljs-comment">/* 指向孩子链表的头指针 */</span>&#125; DataNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /* 树的定义 */</span><span class="hljs-class">&#123;</span>  DataNode nodes[MAX]; <span class="hljs-comment">/* 顺序表 */</span>  <span class="hljs-keyword">int</span> root;            <span class="hljs-comment">/* 该树的根结点在线性表中的位置 */</span>  <span class="hljs-keyword">int</span> num;             <span class="hljs-comment">/* 该树的结点个数 */</span>&#125; ChildTree;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>3.孩子兄弟表示法（最重要）</td></tr></table><ul><li>这种表示法又称为<strong>树的二叉表示法</strong>，或者<strong>二叉链表表示法</strong>，即以二叉链表作为树的存储结构。链表中每个结点设有两个链域，分别指向该结点的第一个孩子结点和下一个兄弟（右兄弟）结点。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200326142115250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>孩子兄弟表示法的类型定义如下：</p></blockquote><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span></span><span class="hljs-class">&#123;</span>  DataType data;              <span class="hljs-comment">/*结点信息*/</span>  Struct CSNode *FirstChild;  <span class="hljs-comment">/*第一个孩子*/</span>  Struct CSNode *Nextsibling; <span class="hljs-comment">/*下一个兄弟*/</span>&#125; CSNode, *CSTree;</code></pre></div><blockquote><p>这种存储结构便于实现树的各种操作，例如，如果要访问结点 x 的第 i 个孩子，则只要先从FirstChild 域找到第一个孩子结点，然后沿着这个孩子结点的 Nextsibling 域连续走 i-1 步，便可找到 x的第 i 个孩子。如果在这种结构中为每个结点增设一个 Parent 域，则同样可以方便地实现查找双亲的操作。</p></blockquote><table><tr><td bgcolor=#E6E6FA><font  size=6>树、森林与二叉树的相互转换</td></tr></table><blockquote><p>前面介绍了树的存储结构和二叉树的存储结构，从中可以看到，树的孩子兄弟链表结构与二叉树的二叉链表结构在物理结构上是完全相同的，只是它们的逻辑含义不同，所以树和森林与二叉树之间必然有着密切的关系。本节介绍树和森林与二叉树之间的相互转换方法。</p></blockquote><table><tr><td bgcolor=#99CCFF><font  size=4>1.树转换为二叉树</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200326143017595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020032614343486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200326143935542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#99CCFF><font  size=4>2.森林转换为二叉树</td></tr></table><ul><li>森林是若干棵树的集合。树可以转换为二叉树，森林同样也可以转换为二叉树。因此，森林也可以方便地用孩子兄弟链表表示。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200326144111761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#99CCFF><font  size=4>3.二叉树还原为树或森林</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200326143805590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=6>树与森林的遍历</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4>1.树的遍历</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200326144406728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200326144411425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>方法一：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RootFirst</span><span class="hljs-params">(CSTree root)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)  &#123;    Visit(root-&gt;data); <span class="hljs-comment">/* 访问根结点 */</span>    p = root-&gt;FirstChild;    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)    &#123;      RootFirst(p); <span class="hljs-comment">/* 访问以 p 为根的子树 */</span>      p = p-&gt;Nextsibling;    &#125;  &#125;&#125;</code></pre></div><p>方法二：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RootFirst</span><span class="hljs-params">(CSTree root)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)  &#123;    Visit(root-&gt;data);            <span class="hljs-comment">/*访问根结点*/</span>    RootFirst(root-&gt;FirstChild);  <span class="hljs-comment">/*先根遍历首子树*/</span>    RootFirst(root-&gt;Nextsibling); <span class="hljs-comment">/*先根遍历兄弟树*/</span>  &#125;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>2.森林的遍历</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200326144808307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200326144821105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200326144829952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>例如，右图中森林的后序遍历序列为 DCBFJIHGEA。<br><img src="https://img-blog.csdnimg.cn/20200326145149927.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>对照二叉树与森林之间的转换关系可以发现，森林的先序遍历、中序遍历和后序遍历与其相应二叉树的先序遍历、中序遍历和后序遍历是对应相同的，因此可以用相应二叉树的遍历结果来验证森林的遍历结果。另外，树可以看成只有一棵树的森林，所以树的先根遍历和后根遍历分别与森林的先序遍历和中序遍历对应。森林的遍历算法可以采用其对应的二叉树的遍历算法来实现。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】由遍历序列确定的二叉树</title>
    <link href="/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200326093435218.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>例</strong>：已知一棵二叉树的先序序列与中序序列分别为：<br> A B C D E F G H I<br> B C A E D G H F I<br> 试构造该二叉树。</p><p>分析：<br>根据定义，二叉树的先序遍历是先访问根结点，其次再按先序遍历方式遍历根结点的左子树，最后按先序遍历方式遍历根结点的右子树。这就是说，在先序序列中，第一个结点一定是二叉树的根结点。如下图（a）所示。<br>另一方面，中序遍历是先遍历左子树，然后访问根结点，最后再遍历右子树。这样，根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列是根结点的右子树的中序序列。如下图（b）所示</p><p><img src="https://img-blog.csdnimg.cn/20200326093851659.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>根据这两个子序列，在先序序列中根据中序序列对应的左子树的先序序列和右子树的先序序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。这样，就确定了二叉树的三个结点。同时，左子树和右子树的根结点又可以分别把左子序列和右子序列划分为两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以得到一棵二叉树。</p><p>具体到本题目，首先由先序序列可知，结点 A 是二叉树的根结点。其次，根据中序序列，在 A 之前的所有结点都是根结点左子树的结点，在 A 之后的所有结点都是根结点右子树的结点，由此得到下图（a）所示的状态。然后再对左子树进行分解，得知 B 是左子树的根结点，又从中序序列知道，B 的左子树为空，B 的右子树只有一个结点 C。接着对 A 的右子树进行分解，得知 A 的右子树的根结点为 D；而结点 D 把其余结点分成两部分，即左子树为 E，右子树为 F、G、H、I，如下图（b）所示。接下去的工作就是按上述原则对 D 的右子树继续分解下去，最后得到如下图（c）所示的整棵二叉树。</p><p><img src="https://img-blog.csdnimg.cn/20200326093954211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】线索二叉树的基本概念及遍历</title>
    <link href="/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%81%8D%E5%8E%86/"/>
    <url>/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6>基本概念</td></tr></table><blockquote><p>我们知道，在有 n 个结点的二叉链表中共有 2n 个链域，但只有 n-1 个有用的非空链域，其余 n+1 个链域是空的。可以利用剩下的 n+1 个空链域来存放遍历过程中结点的前驱和后继信息。</p></blockquote><p>现作如下规定：</p><ul><li>若结点有左子树，则其 LChild 域指向其左孩子，否则 LChild 域指向其前驱结点；</li><li>若结点有右子树，则其 RChild 域指向其右孩子，否则 RChild 域指向其后继结点。</li></ul><p>为了区分孩子结点和前驱、后继结点，为结点结构增设两个标志域，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200325222156168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200325222248343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=6>二叉树的线索化</td></tr></table><p>线索化实质是将二叉链表中的空指针域，填上相应结点的遍历前驱或后继结点的地址，而前驱和后继的地址只能在动态的遍历过程中才能得到。==因此线索化的过程即为在遍历过程中修改空指针域的过程。==</p><p>对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树，包括先序线索二叉树、中序线索二叉树和后序线索二叉树。这里重点介绍<strong>中序线索化</strong>的算法。 </p><p>【算法思想】<br>（1）中序线索化采用中序递归遍历算法框架。<br>（2）加线索操作就是访问结点操作。<br>（3）加线索操作需要利用刚访问过结点与当前结点的关系，因此设置一个指针 pre，始终记录刚访问过的结点，其操作如下：<br>①如果当前遍历结点 root 的左子域为空，则让左子域指向 pre ；<br>②如果前驱 pre 的右子域为空，则让右子域指向当前遍历结点 root；<br>③为下次做准备，当前访问结点 root 作为下一个访问结点的前驱 pre。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* 对 root 所指的二叉树进行中序线索化，其中 pre 始终指向刚访问过的结点，其初值为NULL*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inthread</span><span class="hljs-params">(BiTree root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)    &#123;        Inthread(root-&gt;LChild); <span class="hljs-comment">/* 线索化左子树 */</span>        <span class="hljs-keyword">if</span> (root-&gt;LChild == <span class="hljs-literal">NULL</span>)        &#123;            root-&gt;Ltag = <span class="hljs-number">1</span>;            root-&gt;LChild = pre;            / *置前驱线索 * /        &#125;        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;RChild == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">/* 置后继线索 */</span>        &#123;            pre-&gt;RChild = root;            pre-&gt;Rtag = <span class="hljs-number">1</span>;        &#125;        pre = root；                <span class="hljs-comment">/*当前访问结点为下一个访问结点的前驱*/</span>            Inthread(root-&gt;RChild); <span class="hljs-comment">/*线索化右子树*/</span>    &#125;&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6>在线索二叉树中找前驱，后继结点</td></tr></table><p>以中序线索二叉树为例，来讨论如何在线索二叉树中查找结点的前驱和后继。<br>(1）找结点的中序前驱结点<br>根据线索二叉树的基本概念和存储结构可知，对于结点 p，</p><ul><li>当 p-&gt;Ltag=1 时，p-&gt;LChild 指 向 p 的前驱。</li><li>当 p-&gt;Ltag=0 时，p-&gt;LChild 指向 p 的左孩子。由中序遍历的规律可知，作为根 p 的前驱结点，它是中序遍历 p 的左子树时访问的最后一个结点，即左子树的“最右下端”结点。</li></ul><p>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">BiTNode *<span class="hljs-title">InPre</span><span class="hljs-params">(BiTNode *p)</span></span><span class="hljs-function"><span class="hljs-comment">/* 在中序线索二叉树中查找 p 的中序前驱, 并用 pre 指针返回结果 */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (p-&gt;Ltag == <span class="hljs-number">1</span>)        pre = p-&gt;LChild; <span class="hljs-comment">/*直接利用线索*/</span>    <span class="hljs-keyword">else</span>    &#123; <span class="hljs-comment">/* 在 p 的左子树中查找“最右下端”结点 */</span>        <span class="hljs-keyword">for</span> (q = p-&gt;LChild; q-&gt;Rtag == <span class="hljs-number">0</span>; q = q-&gt;RChild)            ;        pre = q;    &#125;    <span class="hljs-keyword">return</span> (pre);&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200325223823932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>(2）在中序线索树中找结点后继对于结点 p，若要找其后继结点，</p><ul><li><p>当 p-&gt;Rtag=1 时，p-&gt;RChild 即为 p 的后继结点；</p></li><li><p>当 p-&gt;Rtag=0时，说明 p 有右子树，此时 p 的中序后继结点即为其右子树的“最左下端”的结点。</p><p>【算法描述】</p></li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">BiTNode *<span class="hljs-title">InNext</span><span class="hljs-params">(BiTNode *p)</span></span><span class="hljs-function"><span class="hljs-comment">/*在中序线索二叉树中查找 p 的中序后继结点，并用 Next 指针返回结果*/</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (p-&gt;Rtag == <span class="hljs-number">1</span>)        Next = p-&gt;RChild; <span class="hljs-comment">/*直接利用线索*/</span>    <span class="hljs-keyword">else</span>    &#123; <span class="hljs-comment">/*在 p 的右子树中查找“最左下端”结点*/</span>        <span class="hljs-keyword">if</span> (p-&gt;RChild != <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-keyword">for</span> (q = p-&gt;RChild; q-&gt;Ltag == <span class="hljs-number">0</span>; q = q-&gt;LChild)                ;            Next = q;        &#125;        <span class="hljs-keyword">else</span>            Next = <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">return</span> (Next)&#125;</code></pre></div><p>在先序线索树中找结点的后继比较容易，根据先序线索树的遍历过程可知，</p><ul><li>若结点 p 存在左子树，则 p 的左孩子结点即为 p 的后继；</li><li>若结点 p 没有左子树，但有右子树，则 p 的右孩子结点即为 p 的后继；</li><li>若结点 p 既没有左子树，也没有右子树，则结点 p 的 RChild 指针域所指的结点即为 p 的后继。</li></ul><p>用语句表示则为</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (p-&gt;Ltag==<span class="hljs-number">0</span>) Next=p-&gt;Lchild; <span class="hljs-keyword">else</span> Next =p-&gt;RChild;</code></pre></div><p>同样，在后序线索树中查找结点 p 的前驱也很方便。</p><p>在先序线索树中找结点的前驱比较困难。</p><ul><li>若结点 p 是二叉树的根，则 p 的前驱为空；</li><li>若 p是其双亲的左孩子，或者 p 是其双亲的右孩子并且其双亲无左孩子，则 p 的前驱是 p 的双亲<br>结点</li><li>若 p 是双亲的右孩子且双亲有左孩子，则 p 的前驱是其双亲的左子树中按先序遍历时最后访问的那个结点。<table><tr><td bgcolor=#E6E6FA><font  size=6>遍历中序线索树</td></tr></table></li></ul><p>遍历线索树的问题可以分解成两步，第一步是求出某种遍历次序下第一个被访问结点；然后连续求出刚访问结点的后继结点，直至所有的结点均被访问。以遍历中序线索树为例。<br>(1)在中序线索树上求中序遍历的第一个结点<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">BiTNode *<span class="hljs-title">InFirst</span><span class="hljs-params">(BiTree Bt)</span></span><span class="hljs-function"></span>&#123;    BiTNode *p = Bt;    If(!p) <span class="hljs-keyword">return</span> (<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">while</span> (p-&gt;LTag == <span class="hljs-number">0</span>)        p = p-&gt;Lchild;    <span class="hljs-keyword">return</span> p;&#125;</code></pre></div><p>(2)遍历中序二叉线索树：<br>通过调用 InFirst 和 InNext ,可以实现对中序线索树的中序遍历，且不需要使用递归栈。函数 TInOrder 实现了这种遍历</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TInOrder</span><span class="hljs-params">(BiTree Bt)</span></span><span class="hljs-function"></span>&#123;    BITNode *p;    P = InFirst(Bt);    While(p)    &#123;        Visit(p);        p = InNext(p);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】二叉树遍历算法基于栈的递归消除</title>
    <link href="/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E9%80%92%E5%BD%92%E6%B6%88%E9%99%A4/"/>
    <url>/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E9%80%92%E5%BD%92%E6%B6%88%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树的遍历问题递归的问题无法直接转换成循环，所以需要采用工作栈消除递归。工作栈提供一种控制结构，当递归算法进层时需要将信息保留；当递归算法出层时需要从栈区退出上层信息。</p></blockquote><p>递归进层的三件事</p><ol><li>保存本层参数，返回地址</li><li>.传递参数，分配局部数据空间</li><li>控制转移</li></ol><p>递归退层的三件事</p><ol><li>恢复上层 </li><li>传递结果 </li><li>转断点执行<table><tr><td bgcolor=#EED2EE><font  size=6> 中序遍历二叉树的非递归算法</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4> 初步</td></tr></table>【算法思想】 （1） 针对左递归，写出递归进层的三件事。 （2） 接着写出左递归返回时应执行的语句：访问根结点。 （3） 接着针对右递归，写出递归进层的三件事。 （4） 针对递归退层，写出递归退层的三件事（左、右递归公用）。【算法描述】</li></ol><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(BiTree root)</span></span>;&#123;    <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;    p = root;L1:    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">/* 遍历左子树 */</span>    &#123;        top = top + <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (top &gt; m)            <span class="hljs-keyword">return</span>;     <span class="hljs-comment">/*栈满溢出*/</span>        s[top - <span class="hljs-number">1</span>] = p; <span class="hljs-comment">/* 本层参数进栈 */</span>        s[top] = L2;    <span class="hljs-comment">/* 返回地址进栈 */</span>        p = p-&gt;LChild;  <span class="hljs-comment">/* 给下层参数赋值 */</span>        <span class="hljs-keyword">goto</span> L1;        <span class="hljs-comment">/* 转向开始 */</span>    L2:        Visit(p-&gt;data); <span class="hljs-comment">/* 访问根 */</span>        top = top + <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (top &gt; m)            <span class="hljs-keyword">return</span>; <span class="hljs-comment">/*栈满溢出处理*/</span>        ;        s[top - <span class="hljs-number">1</span>] = p; <span class="hljs-comment">/* 遍历右子树 */</span>        s[top] = L3;        p = p-&gt;RChild;        <span class="hljs-keyword">goto</span> L1;    &#125;L3:    <span class="hljs-keyword">if</span> (top != <span class="hljs-number">0</span>)    &#123;        addr = s[top];        p = s[top - <span class="hljs-number">1</span>]; <span class="hljs-comment">/* 取出返回地址 */</span>        top = top - <span class="hljs-number">2</span>;  <span class="hljs-comment">/* 退出本层参数 */</span>        <span class="hljs-keyword">goto</span> addr;    &#125;&#125;</code></pre></div><p>可看到，直接按定义得到的上述算法结构并不好，为使程序合理组织，需去掉goto 语句, 用循环句代替 if 与 goto, 此时返回断点已无保留的必要，栈区只需保留本层参数即可。整理后的算法框图如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200325220052568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#99CCFF><font  size=4> 直接实现桟操作</td></tr></table><p>中序遍历非递归算法需要设置一个堆栈，用以保留结点指针，以便在遍历完某个结点的左子树后，由该结点指针找到该结点的右子树。<br>【算法思想】<br>从根结点开始，只要当前结点存在，或者栈不空，则重复下面操作：<br>（1） 从当前结点开始，进栈并走左子树，直到左子树为空。<br>（2） 退栈并访问。<br>（3） 走右子树。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*s[m] 表示栈，top 表示栈顶指针*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(BiTree root)</span> <span class="hljs-comment">/* 中序遍历二叉树，root 为二叉树的根结点 */</span></span><span class="hljs-function"></span>&#123;    top = <span class="hljs-number">0</span>;    p = root;    <span class="hljs-keyword">do</span>    &#123;        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-keyword">if</span> (top &gt; m)                <span class="hljs-keyword">return</span>;            top = top + <span class="hljs-number">1</span>;            s[top] = p;            p = p-&gt;LChild;        &#125; <span class="hljs-comment">/* 遍历左子树 */</span>        <span class="hljs-keyword">if</span> (top != <span class="hljs-number">0</span>)        &#123;            p = s[top];            top = top - <span class="hljs-number">1</span>;            Visit(p-&gt;data); <span class="hljs-comment">/* 访问根结点 */</span>            p = p-&gt;RChild;        &#125; <span class="hljs-comment">/* 遍历右子树 */</span>    &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> || top != <span class="hljs-number">0</span>);&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>调用栈操作的函数</td></tr></table><p>【算法思想】从根结点开始，只要当前结点存在，或者栈不空，则重复下面操作：<br>（1） 如果当前结点存在，则进栈并走左子树。<br>（2） 否则退栈并访问，然后走右子树。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> InOrder（BiTree root） <span class="hljs-comment">/* 中序遍历二叉树的非递归算法 */</span>&#123;    InitStack(&amp;S);    p = root;    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> || !IsEmpty(S))    &#123;        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">/* 根指针进栈，遍历左子树 */</span>        &#123;            Push(&amp;S, p);            p = p-&gt;LChild;        &#125;        <span class="hljs-keyword">else</span>        &#123; <span class="hljs-comment">/*根指针退栈，访问根结点，遍历右子树*/</span>            Pop(&amp;S, &amp;p);            Visit(p-&gt;data);            p = p-&gt;RChild;        &#125;    &#125;&#125;</code></pre></div><blockquote><p>递归算法的<strong>时间</strong>复杂度分析：对有 n 个结点二叉树，该算法每循环一次，p 指向一个结点或空（无左孩子或无右孩子的结点的空链域），因此指向空的次数为n+1，n 为结点个数，故循环次数为 n+(n+1)=2n+1,因此算法的复杂度为 O(n)。<br>递归算法的<strong>空间</strong>复杂度分析：所需栈的空间最多等于二叉树深度 K 乘以每个结点所需空间数，记作 O(K)。表面上看，递归算法好象并没有使用栈，实际上递归算法的执行需要反复多次的自己调用自己。每调用一次，系统内部都有系统运行栈区在支持，这是隐含的栈，需要保留本层参数、临时变量与返回地址等。随着函数递归调用，运行栈继续增长，直到函数执行完，才彻底释放占用的栈空间。因此递归算法比非递归算法占用的空间更多。</p></blockquote><table><tr><td bgcolor=#EED2EE><font  size=6> 后序遍历二叉树的非递归算法</td></tr></table><p>后序遍历的非递归算法比较复杂。由于后序遍历是 LRD，要求左、右子树都访问完后，最后访问根结点。如何判断当前栈顶结点的左、右子树都已访问过？解决的方案有多种，采用的方法是：<strong>判断刚访问过的结点 q 是不是当前栈顶结点 p 的右孩子。</strong><br>判别是否应该访问当前栈顶结点 p 时，有两种情况：<br>（1）p 无右孩子，此时应该访问根结点；<br>（2）如 p 的右孩子是刚被访问过的结点 q（表明 p 的右子树已遍历过），此时也应该访问根结点。除这两种情况外，均不应访问根，而是要继续进入右子树中。<br>因此，算法采用了记录刚访问结点的方法，以便在遍历过程中利用前驱 q 与当前结点 p 的关系做判别。<br>【算法思想】从根结点开始，只要当前结点存在，或者栈不空，则重复下面操作：<br>（1） 从当前结点开始，进栈并走左子树，直到左子树为空；<br>（2） 如果栈顶结点的右子树为空，或者栈顶结点的右子孩子为刚访问过的结点，则退栈并访问，然后将当前结点指针置为空；<br>（3） 否则，走右子树。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> PostOrder（BiTree root）&#123;    BiTNode *p, *q；                    Stack S;    q = <span class="hljs-literal">NULL</span>;    p = root;    InitStack(&amp;S);    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> || !IsEmpty(S))    &#123;        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)        &#123;            Push(&amp;S, p);            p = p-&gt;LChild;        &#125; <span class="hljs-comment">/*遍历左子树*/</span>        <span class="hljs-keyword">if</span> (!IsEmpty(S))        &#123;            GetTop(&amp;S, &amp;p);            <span class="hljs-keyword">if</span> ((p-&gt;RChild == <span class="hljs-literal">NULL</span>) || (p-&gt;RChild == q)) <span class="hljs-comment">/* 无右孩子，或右孩子已遍历过 */</span>            &#123;                visit(p-&gt;data); <span class="hljs-comment">/* 访问根结点*/</span>                q = p;          <span class="hljs-comment">/*保存到 q，为下一次已处理结点前驱 */</span>                Pop(&amp;S, &amp;p);                p = <span class="hljs-literal">NULL</span>;            &#125;            <span class="hljs-keyword">else</span>                p = p-&gt;RChild;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】树的基本概念</title>
    <link href="/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
    <url>/2020/06/17/%E3%80%90%E6%A0%91%E3%80%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#FF9933><font  size=5>输出二叉树中的结点</td></tr></table><p>【算法思想】<br>输出二叉树中的结点并无次序要求，因此可用三种遍历算法中的任何一种完成，只需将访问操作具体变为输出操作即可。下面给出采用先序遍历实现的算法。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span><span class="hljs-function"><span class="hljs-comment">/* 先序遍历输出二叉树结点, root 为指向二叉树根结点的指针 */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, root-&gt;data); <span class="hljs-comment">/* 输出根结点 */</span>        PreOrder(root-&gt;LChild);   <span class="hljs-comment">/* 先序遍历左子树 */</span>        PreOrder(root-&gt;RChild);   <span class="hljs-comment">/* 先序遍历右子树 */</span>    &#125;&#125;</code></pre></div><table><tr><td bgcolor=#FF9933><font  size=5>输出二叉树中的叶子结点</td></tr></table><p>【算法思想】<br>输出二叉树中的叶子结点与输出二叉树中的结点相比，它是一个有条件的输出问题，即在遍历过程中走到每一个结点时需进行测试，看是否满足叶子结点的条件。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span><span class="hljs-function"><span class="hljs-comment">/* 先序遍历输出二叉树中的叶子结点 , root 为指向二叉树根结点的指针 */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-keyword">if</span> (root-&gt;LChild == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;RChild == <span class="hljs-literal">NULL</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, root-&gt;data); <span class="hljs-comment">/* 输出叶子结点 */</span>        PreOrder(root-&gt;LChild);       <span class="hljs-comment">/* 先序遍历左子树 */</span>        PreOrder(root-&gt;RChild);       <span class="hljs-comment">/* 先序遍历右子树 */</span>    &#125;&#125;</code></pre></div><table><tr><td bgcolor=#FF9933><font  size=5>统计叶子结点数目</td></tr></table><ul><li>方法一</li></ul><p>【算法思想】<br>统计二叉树中的叶子结点数目并无次序要求，因此可用三种遍历算法中的任何一种完成，只需将访问操作具体变为判断是否为叶子结点及统计操作即可。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* LeafCount 为保存叶子结点数目的全局变量,调用之前初始化值为 0 */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leaf</span><span class="hljs-params">(BiTree root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)    &#123;        leaf(root-&gt;LChild);        leaf(root-&gt;RChild);        <span class="hljs-keyword">if</span> (root-&gt;LChild == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;RChild == <span class="hljs-literal">NULL</span>)            LeafCount++;    &#125;&#125;</code></pre></div><ul><li>方法二</li></ul><p>【算法思想】<br>给出求叶子点数目的递归定义：<br>1）如果是空树，返回 0；<br>2）如果只有一个结点，返回 1；<br>3）否则为左右子树的叶子结点数之和。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">leaf</span><span class="hljs-params">(BiTree root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> LeafCount;    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)        LeafCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((root-&gt;LChild == <span class="hljs-literal">NULL</span>) &amp;&amp; (root-&gt;RChild == <span class="hljs-literal">NULL</span>))        LeafCount = <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 叶子数为左右子树的叶子数目之和 */</span>        LeafCount = leaf(root-&gt;LChild) + leaf(root-&gt;RChild);    <span class="hljs-keyword">return</span> LeafCount;&#125;</code></pre></div><table><tr><td bgcolor=#FF9933><font  size=5>建立二叉链表方式存储的二叉树</td></tr></table><ul><li>给定一棵二叉树，我们可以得到它的遍历序列；</li><li>反过来，给定一棵二叉树的遍历序列，我们也可以创建相应的二叉链表。</li></ul><p>这里所说的遍历序列是一种“扩展的遍历序列”。在通常的遍历序列中，均忽略空子树，而在扩展的遍历序列中，必须用特定的元素表示空子树。例如，图中二叉树的“扩展先序遍历序列”为：AB.DF..G..C.E.H..  其中用小圆点表示空子树。<img src="https://img-blog.csdnimg.cn/20200325173711502.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>【算法思想】<br>采用类似先序遍历的递归算法，首先读入当前根结点的数据，如果是“.”则将当前树根置为空，否则申请一个新结点，存入当前根结点的数据，分别用当前根结点的左子域和右子域进行递归调用，创建左、右子树。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree *bt)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> ch;    ch = getchar();    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'.'</span>)        *bt = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">else</span>    &#123;        *bt = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));        (*bt)-&gt;data = ch;        CreateBiTree(&amp;((*bt)-&gt;LChild));        CreateBiTree(&amp;((*bt)-&gt;RChild));    &#125;&#125;</code></pre></div><table><tr><td bgcolor=#FF9933><font  size=5>求二叉树的高度</td></tr></table><p>二叉树的高度（深度）为二叉树中结点层次的最大值，也可视为其左、右子树高度的最大值加 1。<br>【算法思想】<br>二叉树 bt 高度的递归定义如下</p><ul><li>若 bt 为空，则高度为 0。</li><li>若 bt 非空，其高度应为其左、右子树高度的最大值加 1，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200325174821385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>【算法描述】</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PostTreeDepth</span><span class="hljs-params">(BiTree bt)</span> <span class="hljs-comment">/* 后序遍历求二叉树 bt 高度的递归算法 */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> hl, hr, <span class="hljs-built_in">max</span>;    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)    &#123;        hl = PostTreeDepth(bt-&gt;LChild); <span class="hljs-comment">/* 求左子树的深度 */</span>        hr = PostTreeDepth(bt-&gt;RChild); <span class="hljs-comment">/* 求右子树的深度 */</span>        <span class="hljs-built_in">max</span> = hl &gt; hr ? hl : hr;        <span class="hljs-comment">/* 得到左、右子树深度较大者*/</span>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">max</span> + <span class="hljs-number">1</span>);               <span class="hljs-comment">/* 返回树的深度 */</span>    &#125;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <span class="hljs-comment">/* 如果是空树，则返回 0 */</span>&#125;</code></pre></div><p>求二叉树的高度是也可用前序遍历的方式实现。<br>【算法思想】<br>二叉树的高度（深度）为二叉树中结点层次的最大值。设根结点为第一层的结点，所有 h 层的结点的左、右孩子结点在 h+1 层。故可以通过遍历计算二叉树中的每个结点的层次，其中最大值即为二叉树的高度。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreTreeDepth</span><span class="hljs-params">(BiTeee bt, <span class="hljs-keyword">int</span> h)</span></span><span class="hljs-function"><span class="hljs-comment">/* 先序遍历求二叉树 bt 高度的递归算法，h 为 bt 指向结点所在层次，初值为 1*/</span></span><span class="hljs-function"><span class="hljs-comment">/*depth 为当前求得的最大层次，为全局变量，调用前初值为 0 */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (bt != <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-keyword">if</span> (h &gt; depth)            depth = h;                   <span class="hljs-comment">/*如果该结点层次值大于 depth，更新 depth的值*/</span>        PreTreeDepth(bt-&gt;Lchild, h + <span class="hljs-number">1</span>); <span class="hljs-comment">/* 遍历左子树 */</span>        PreTreeDepth(bt-&gt;Rchild, h + <span class="hljs-number">1</span>); <span class="hljs-comment">/* 遍历右子树 */</span>    &#125;&#125;</code></pre></div><table><tr><td bgcolor=#FF9933><font  size=5>按树状打印二叉树</td></tr></table>假设以二叉链表存储的二叉树中，每个结点所含数据元素均为单字母。 要求实现二叉树的横向显示问题，如下图所示打印结果。<p><img src="https://img-blog.csdnimg.cn/20200325180521199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>【算法思想】<br>（1）二叉树的横向显示应是二叉树竖向显示的 90。旋转。分析上图示可知，这种树形打印格式要求先打印右子树，再打印根，最后打印左子树，按由上而下顺序看，其输出的结点序为：CFEADB，这恰为逆中序顺序。解决二叉树的横向显示问题采用“逆中序”遍历框架，所以横向显示二叉树算法为先右子树、再根结点、再左子树的 RDL 结构。<br>（2）在这种输出格式中，结点的左、右位置与结点的层深有关，故算法中设置了一个表示当前根结点层深的参数，以控制输出结点的左、右位置，每当递归进层时层深参数加 1。这些操作应在访问根结点时实现。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintTree</span><span class="hljs-params">(BiTree bt, <span class="hljs-keyword">int</span> nLayer)</span></span><span class="hljs-function"><span class="hljs-comment">/* 按竖向树状打印的二叉树 */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (bt == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span>;    PrintTree(bt-&gt;RChild, nLayer + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nLayer; i++)        <span class="hljs-built_in">printf</span>(“ ”);    <span class="hljs-built_in">printf</span>(“% c\n”, bt-&gt;data);    <span class="hljs-comment">/*按逆中序输出结点，用层深决定的左、右位置*/</span>    PrintTree(bt-&gt;LChild, nLayer + <span class="hljs-number">1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【图】图的存储结构</title>
    <link href="/2020/05/10/%E3%80%90%E5%9B%BE%E3%80%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2020/05/10/%E3%80%90%E5%9B%BE%E3%80%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=5> 邻接矩阵表示法 </td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200509124528370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200510092123747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>邻接矩阵表示法的 C 语言描述</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VERTEX_NUM 20 <span class="hljs-comment">/*最多顶点个数*/</span> </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INFINITY 32768 <span class="hljs-comment">/*表示极大值，即∞*/</span></span><span class="hljs-comment">/* 图的种类：DG 表示有向图, DN 表示有向网, UDG 表示无向图, UDN 表示无向网 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;  DG,  DN,  UDG,  UDN&#125; GraphKind;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> VertexData; <span class="hljs-comment">/*假设顶点数据为字符型*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span></span><span class="hljs-class">&#123;</span>  AdjType adj; <span class="hljs-comment">/* 对于无权图，用 1 或 0 表示是否相邻； 对带权图，则为权值类型 */</span>  OtherInfo info;&#125; ArcNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  VertexData vertex[MAX_VERTEX_NUM];            <span class="hljs-comment">/*顶点向 量*/</span>  ArcNode arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; <span class="hljs-comment">/*邻接矩阵*/</span>  <span class="hljs-keyword">int</span> vexnum, arcnum;                           <span class="hljs-comment">/*图的顶点数和弧数*/</span>  GraphKind kind;                               <span class="hljs-comment">/*图的种类标志*/</span>&#125; AdjMatrix;                                    <span class="hljs-comment">/*（Adjacency Matrix Graph）*/</span></code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5>邻接矩阵表示法的特点</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200510093155509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200510093231183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>用邻接矩阵法创建有向网的算法</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LocateVertex</span><span class="hljs-params">(AdjMatrix *G, VertexData v)</span> <span class="hljs-comment">/*求顶点位置函数*/</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> j = Error, k;  <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; G-&gt;vexnum; k++)    <span class="hljs-keyword">if</span> (G-&gt;vertex[k] == v)    &#123;      j = k;      <span class="hljs-keyword">break</span>;    &#125;  <span class="hljs-keyword">return</span> (j);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateDN</span><span class="hljs-params">(AdjMatrix *G)</span> <span class="hljs-comment">/*创建一个有向网*/</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> i, j, k, weight;  VertexData v1, v2;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d,%d"</span>, &amp;G-&gt;arcnum, &amp;G-&gt;vexnum); <span class="hljs-comment">/*输入图的顶点数和弧数*/</span>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexnum; i++)         <span class="hljs-comment">/*初始化邻接矩阵*/</span>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;vexnum; j++)      G-&gt;arcs[i][j].adj = INFINITY;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;vexnum; i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>, &amp;G-&gt;vertex[i]); <span class="hljs-comment">/* 输入图的顶点*/</span>  <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; G-&gt;arcnum; k++)  &#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c,%c,%d"</span>, &amp;v1, &amp;v2, &amp;weight); <span class="hljs-comment">/*输入一条弧的两个顶点及权 值*/</span>    i = LocateVex_M(G, v1);    j = LocateVex_M(G, v2);    G-&gt;arcs[i][j].adj = weight; <span class="hljs-comment">/*建立弧*/</span>  &#125;  <span class="hljs-keyword">return</span> (Ok);&#125;</code></pre></div><blockquote><p>该算法的时间复杂度为 O（n2+e×n），其中 O（n2）时间耗费在对二维数组 arcs 的每个分量的 arj 域初始化赋值上。O（e×n）的时间耗费在有向网中边权的赋值上</p></blockquote><table><tr><td bgcolor=#E6E6FA><font  size=5> 邻接表表示法  </td></tr></table>（实际上是一种链式存储结构）<p><img src="https://img-blog.csdnimg.cn/2020051009483845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>如下图所示分别是图 G1、G2 邻接表表示示例，其中边表中顶点无顺序要求。</p><p><img src="https://img-blog.csdnimg.cn/20200510095740577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>邻接表存储结构的形式化</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VERTEX_NUM 20 <span class="hljs-comment">/*最多顶点个数*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;  DG,  DN,  UDG,  UDN&#125; GraphKind; <span class="hljs-comment">/*图的种类*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">int</span> adjvex;              <span class="hljs-comment">/*该弧指向顶点的位置*/</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">nextarc</span>;</span> <span class="hljs-comment">/*指向下一条弧的指针*/</span>  OtherInfo info;          <span class="hljs-comment">/*与该弧相关的信息*/</span>&#125; ArcNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VertexNode</span></span><span class="hljs-class">&#123;</span>  VertexData data;   <span class="hljs-comment">/*顶点数据*/</span>  ArcNode *firstarc; <span class="hljs-comment">/*指向该顶点第一条弧的指针*/</span>&#125; VertexNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  VertexNode vertex[MAX_VERTEX_NUM];  <span class="hljs-keyword">int</span> vexnum, arcnum; <span class="hljs-comment">/*图的顶点数和弧数*/</span>  GraphKind kind;     <span class="hljs-comment">/*图的种类标志*/</span>&#125; AdjList;            <span class="hljs-comment">/*基于邻接表的图(Adjacency List Graph)*/</span></code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200510095932653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200510100035237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=5> 十字链表 </td></tr></table><blockquote><p>十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个 结点，叫做顶点结点。这两类结点结构如下图所示</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200510100324607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>例如：有向图 G1 的十字链表表示如下图所示。若有向图是稀疏图，则它的 邻接矩阵一定是稀疏矩阵，这时该图的十字链表表示法可以看成是其邻接矩阵的 链表表示法。只是在图的十字链表表示法中，弧结点所在的链表不是循环链表且 结点之间相对位置自然形成，不一定按顶点序号有序。另外，表头结点即顶点结 点，它们之间并非循环链式连接，而是顺序存储。</p><table><tr><td bgcolor=#FFC0CB><font  size=5>十字链表存储结构的形式化</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VERTEX_NUM 20 <span class="hljs-comment">/*最多顶点个数*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;  DG,  DN,  UDG,  UDN&#125; GraphKind; <span class="hljs-comment">/*图的种类*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">int</span> tailvex, headvex;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">hlink</span>, *<span class="hljs-title">tlink</span>;</span>&#125; ArcNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VertexNode</span></span><span class="hljs-class">&#123;</span>  VertexData data; <span class="hljs-comment">/*顶点信息*/</span>  ArcNode *firstin, *firstout;  tailvex&#125; VertexNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  VertexNode vertex[MAX_VERTEX_NUM];  <span class="hljs-keyword">int</span> vexnum, arcnum; <span class="hljs-comment">/*图的顶点数和弧数*/</span>  GraphKind kind;     <span class="hljs-comment">/*图的种类*/</span>&#125; OrthList;           <span class="hljs-comment">/*图的十字链表表示法(Orthogonal List)*/</span></code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200510100515499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>建立有向图的十字链表的算法</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> CrtOrthList（OrthList *g） <span class="hljs-comment">/*从终端输入 n 个顶点的信息和 e 条弧的信息，以建立一个有向图的十字链表*/</span>&#123;  <span class="hljs-built_in">scanf</span>(“% d, % d”, &amp;n, &amp;e); <span class="hljs-comment">/*从键盘输入图的顶点个数和弧的个数*/</span>  g-&gt;vexnum = n;  g-&gt;arcnum = e;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)  &#123;    <span class="hljs-built_in">scanf</span>(“% c”, &amp;(g-&gt;vertex[i].data));    g-&gt;vertex[i].firstin = <span class="hljs-literal">NULL</span>;    g-&gt;vertex[i].firsout = <span class="hljs-literal">NULL</span>;  &#125;  <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; e; k++)  &#123;    <span class="hljs-built_in">scanf</span>(“% c, % c”, &amp;vt, &amp;vh);    i = LocateVertex（g，vt）;    j = LocateVertex（g，vh）;    p = (ArcNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ArcNode));    p-&gt;tailvex = I;    p-&gt;headvex = j;    p-&gt;tlink = g-&gt;vertex[i].firstout;    g-&gt;vertex[i].firstout = p;    p-&gt;hlink = g-&gt;vertex[j].firstin;    g-&gt;vertex[j].firstin = p;  &#125;&#125; <span class="hljs-comment">/* CrtOrthList */</span></code></pre></div><blockquote><p>在十字链表中既能够很容易地找到以 vi 为尾的弧，也能够容易地找到以 vi 为头的弧，因此对于有向图，若采用十字链表作为存储结构，则很容易求出顶点 vi的度。此外，为有向图建立一个邻接表的算法和建立一个十字链表的算法的时 间复杂度是相同的。所以，在某些有向图的应用中，十字链表表示法更为合适</p></blockquote><table><tr><td bgcolor=#E6E6FA><font  size=5> 邻接多重表 </td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200510100813305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>邻接多重表的结构类型说明</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VERTEX_NUM 20 <span class="hljs-comment">/*最多顶点个数*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">int</span> mark, ivex, jvex;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span> *<span class="hljs-title">ilink</span>, *<span class="hljs-title">jlink</span>;</span>&#125; EdgeNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  VertexData data;  EdgeNode *firstedge;&#125; VertexNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  VertexNode vertex[MAX_VERTEX_NUM];  Int vexnum, arcnum; <span class="hljs-comment">/*图的顶点数和弧数*/</span>  GraphKind kind;     <span class="hljs-comment">/*图的种类*/</span>&#125; AdjMultiList;       <span class="hljs-comment">/*基于图的邻接多重表表示法(Adjacency Multi_list)*/</span></code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200510100906315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【图】图的基本概念</title>
    <link href="/2020/05/09/%E3%80%90%E5%9B%BE%E3%80%91%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20-%20%E5%89%AF%E6%9C%AC%20(2)/"/>
    <url>/2020/05/09/%E3%80%90%E5%9B%BE%E3%80%91%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%20-%20%E5%89%AF%E6%9C%AC%20(2)/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#FFC0CB><font  size=5>图的定义</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200416074033914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200416074346152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200416074349919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>图的基本术语</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200416074614399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200416074620180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200509121952235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200509122244659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200509122352264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200509122414745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【图】图的基本概念</title>
    <link href="/2020/05/09/%E3%80%90%E5%9B%BE%E3%80%91%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/05/09/%E3%80%90%E5%9B%BE%E3%80%91%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#FFC0CB><font  size=5>图的定义</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200416074033914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200416074346152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200416074349919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>图的基本术语</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200416074614399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200416074620180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200509121952235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200509122244659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200509122352264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200509122414745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】Fibonacci数列</title>
    <link href="/2020/05/08/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91Fibonacci%E6%95%B0%E5%88%97/"/>
    <url>/2020/05/08/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91Fibonacci%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题描述<br>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。<br>当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。</p></blockquote><p>输入格式<br>输入包含一个整数n。<br>输出格式<br>输出一行，包含一个整数，表示Fn除以10007的余数。</p><blockquote><p>说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。</p></blockquote><p>样例输入<br>10<br>样例输出<br>55<br>样例输入<br>22<br>样例输出<br>7704<br>数据规模与约定<br>1 &lt;= n &lt;= 1,000,000。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> n, i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, f;    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">3</span>; i &lt;= n; i++)        &#123;            f = (a + b) % <span class="hljs-number">10007</span>; <span class="hljs-comment">// 取余公式</span>            a = b;            b = f;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, f);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>重点是取余公式<br>（a+b）%x=（a%x+b%x）%x</p>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>算法</category>
      
      <category>递归</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】二叉树的遍历及递归遍历算法</title>
    <link href="/2020/03/25/%E3%80%90%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/25/%E3%80%90%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#EED2EE><font  size=6> 二叉树遍历的定义</td></tr></table><p>二叉树的遍历：按一定规律对二叉树中的每个结点进行访问且仅访问一次。其中的访问可指计算二叉树中结点的数据信息，打印该结点的信息，也包括对结点进行任何其他操作。</p><blockquote><p>为什么需要遍历二叉树？<br>二叉树是非线性数据结构，通过遍历可以将二叉树中的结点访问一次且仅一次，从而得到访问结点的顺序序列。从这个意义上说，遍历操作就是将二叉树中结点按一定规律线性化的操作，目的在于将非线性化结构变成线性化的访问序列。</p></blockquote><table><tr><td bgcolor=#EED2EE><font  size=6> 二叉树遍历的规律及相关递归遍历算法</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200325153122982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#99CCFF><font  size=4>先序遍历</td></tr></table><p>（1）先序遍历（DLR）操作过程<br> 若二叉树为空，则空操作，否则依次执行如下 3 个操作：<br> ① 访问根结点；<br> ② 按先序遍历左子树；<br> ③ 按先序遍历右子树。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span></span><span class="hljs-function"><span class="hljs-comment">/*先序遍历二叉树, root 为指向二叉树(或某一子树)根结点的指针*/</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)    &#123;        Visit(root-&gt;data);      <span class="hljs-comment">/*访问根结点*/</span>        PreOrder(root-&gt;LChild); <span class="hljs-comment">/*先序遍历左子树*/</span>        PreOrder(root-&gt;RChild); <span class="hljs-comment">/*先序遍历右子树*/</span>    &#125;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>中序遍历</td></tr></table><p>（2）中序遍历（LDR）操作过程<br> 若二叉树为空，则空操作，否则依次执行如下 3 个操作：<br> ① 按中序遍历左子树；<br> ② 访问根结点；<br> ③ 按中序遍历右子树。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span></span><span class="hljs-function"><span class="hljs-comment">/*中序遍历二叉树, root 为指向二叉树(或某一子树)根结点的指针*/</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)    &#123;        InOrder(root-&gt;LChild); <span class="hljs-comment">/*中序遍历左子树*/</span>        Visit(root-&gt;data);     <span class="hljs-comment">/*访问根结点*/</span>        InOrder(root-&gt;RChild); <span class="hljs-comment">/*中序遍历右子树*/</span>    &#125;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>后序遍历</td></tr></table><p>（3）后序遍历（LRD）操作过程<br> 若二叉树为空，则空操作，否则依次执行如下 3 个操作：<br> ① 按后序遍历左子树；<br> ② 按后序遍历右子树；<br> ③ 访问根结点。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span></span><span class="hljs-function"><span class="hljs-comment">/* 后序遍历二叉树，root 为指向二叉树(或某一子树)根结点的指针*/</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)    &#123;        PostOrder(root-&gt;LChild); <span class="hljs-comment">/*后序遍历左子树*/</span>        PostOrder(root-&gt;RChild); <span class="hljs-comment">/*后序遍历右子树*</span><span class="hljs-comment"> Visit(root -&gt;data); /*访问根结点*/</span>    &#125;&#125;</code></pre></div><blockquote><p>递归算法的时间复杂度分析：设二叉树有 n 个结点，对每个结点都要进行一次入栈和出栈的<br>操作，即入栈和出栈各执行 n 次，对结点的访问也是 n 次。这些二叉树递归遍历算法的时间<br>复杂度为 O(n)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200325160540415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200325160547524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】二叉树的基本概念与性质</title>
    <link href="/2020/03/24/%E3%80%90%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/"/>
    <url>/2020/03/24/%E3%80%90%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6>二叉树的定义与基本操作</td></tr></table><p>1.定义：把满足以下两个条件的树型结构叫做二叉树（Binary Tree）： </p><ul><li>（1） 每个结点的度都不大于 2； </li><li>（2） 每个结点的孩子结点次序不能任意颠倒。</li></ul><p>由此定义可看出，一个二叉树中的每个结点只能含有 0、1 或 2 个孩子，而且每个孩子有左右之分。位于左边的孩子叫做左孩子，位于右边的孩子叫做右孩子。</p><p><img src="https://img-blog.csdnimg.cn/20200324082008622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200324082132451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=6>二叉树的性质</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=5>性质1：在二叉树的第 i 层上至多有 2^（i-1）个结点(i≥1)。</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324082707676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>性质2：深度为 k 的二叉树至多有 2^k-1 个结点（k≥1）。</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324082851101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>性质3:对任意一棵二叉树 T，若终端结点数为 n0，而其度数为 2 的结点数为 n2，则 n0= n2+1</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324084006519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>满二叉树</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324093323216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>满二叉树的顺序表示，即从二叉树的根开始，层间从上到下，层内从左到右，逐层进行编号（1，2，···，n）</p><table><tr><td bgcolor=#FFC0CB><font  size=5>完全二叉树</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324093528346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>性质4：具有 n 个结点的完全二叉树的深度为 [log2 n]+1</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324093852429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>性质5</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324094244502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=6>二叉树的存储结构</td></tr></table><p>二叉树是非线性的，每一个结点最多有两个直接后继</p><table><tr><td bgcolor=#FFC0CB><font  size=5>顺序存储</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324094755940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200324095215449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>链式存储</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200324095341622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><span class="hljs-class">&#123;</span>    DataType data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LChild</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">RChild</span>;</span>&#125; BiTNode, *BiTree;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200324095628337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>若一个二叉树含有 n 个结点，则它的二叉链表中必含有 2n 个指针域，其中必有 n＋1 个空的链域。<br>证明：分支数目 B=n-1，即非空的链域有 n-1 个，故空链域有 2n-(n-1)=n+1 个。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树】树的基本概念</title>
    <link href="/2020/03/23/%E3%80%90%E6%A0%91%E3%80%91%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/03/23/%E3%80%90%E6%A0%91%E3%80%91%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6>树的定义与基本术语</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=5>树的基本概念</td></tr></table><ul><li>树是 n（n≥0）个结点的有限集合 T。</li><li>当 n=0 时，称为空树；</li><li>当 n&gt;0 时，该集合满足如下条件：①其中必有一个称为<strong>根</strong>（root）的特定结点，它没有直接前驱，但有零个或多个直接后继。②其余 n-1 个结点可以划分成 m（m≥0）个互不相交的有限集 T1，T2，T3，…，Tm，其中Ti又是一棵树，称为<strong>根的子树</strong>。<strong>每棵子树的根结点有且仅有一个直接前驱</strong>，但有零个或多个直接后继。<br>下图给出了一棵树的逻辑结构图示，它如同一棵倒长的树。<br><img src="https://img-blog.csdnimg.cn/20200323212318362.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><table><tr><td bgcolor=#FFC0CB><font  size=5>树的图解表示</td></tr></table></li></ul><p><img src="https://img-blog.csdnimg.cn/20200323212855495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200323212907526.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=5>树的相关术语</td></tr></table><ul><li><strong>结点</strong>：包括一个数据元素及若干指向其他结点的分支信息。 </li><li><strong>结点的度</strong>：一个结点的==子树个数==称为此结点的度。 </li><li><strong>叶结点</strong>：==度为 0 的结点==，即无后继的结点，也称为终端结点。</li><li><strong>分支结点</strong>：度不为 0 的结点，也称为非终端结点。</li><li><strong>结点的层次</strong>：从根结点开始定义，根结点的层次为 1，根的直接后继的层次为 2，依此类推。</li><li><strong>结点的层序编号</strong>：将树中的结点按从上层到下层、同层从左到右的次序排成一个线性序列，依次给它们编以连续的自然数。</li><li><strong>树的度</strong>：==树中所有结点的<strong>度</strong>的最大值。== </li><li><strong>树的高度（深度）</strong>：==树中所有结点的<strong>层次</strong>的最大值。== </li><li><strong>有序树</strong>：在树 T 中，如果各子树 Ti之间是有先后次序的，则称为有序树。 </li><li><strong>森林</strong>：m（m≥0）棵互不相交的树的集合。将一棵非空树的根结点删去，树就变成一个森林；反之，给森林增加一个统一的根结点，森林就变成一棵树。</li><li><strong>同构</strong>：对两棵树，通过对结点适当地重命名，就可以使两棵树完全相等（结点对应相等，对应结点的相关关系也相等），则称这两棵树同构。 </li></ul><p>我们常常借助人类家族树的术语，以便于直观理解结点间的层次关系。</p><ul><li>孩子结点：一个结点的直接后继称为该结点的孩子结点。</li><li>双亲结点：一个结点的直接前驱称为该结点的双亲结点。</li><li>兄弟结点：同一双亲结点的孩子结点之间互称兄弟结点。</li><li>堂兄弟：父亲是兄弟关系或堂兄关系的结点称为堂兄弟结点。</li><li>祖先结点：一个结点的祖先结点是指从根结点到该结点的路径上的所有结点。</li><li>子孙结点：一个结点的直接后继和间接后继称为该结点的子孙结点。</li><li>前辈：层号比该结点小的结点，都称为该结点的前辈。</li><li>后辈：层号比该结点大的结点，都称为该结点的后辈。<table><tr><td bgcolor=#FFC0CB><font  size=5>树的抽象数据类型</td></tr></table></li></ul><p><img src="https://img-blog.csdnimg.cn/20200323215117652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【串】串的链式存储结构与应用例题</title>
    <link href="/2020/03/23/%E3%80%90%E4%B8%B2%E3%80%91%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BA%94%E7%94%A8%E4%BE%8B%E9%A2%98/"/>
    <url>/2020/03/23/%E3%80%90%E4%B8%B2%E3%80%91%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BA%94%E7%94%A8%E4%BE%8B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6>块链串</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200323145710245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果一个结点大小为 4 ,链域大小为 2 ,根据<strong>存储密度=串值占用的存储位/实际为串分配存储位,故该字符串的存储密度为 2 /3 。</strong>显然,串的存储密度越小,运算处理就越方便,但存储占用的量较大。应根据具体情况来确定使用串的何种存储结构。</p><ol><li>结点大小等于 1 :当 BLOCK_SIZE 等于 1 时,每个结点存放 1 个字符,结构同线性链表,存<br>储结构可定义如下,插入、删除的处理方法和线性链表一样,参见本章典型题解部分串的链式<br>模式匹配,算法处理简单,但存储密度较低。</li><li>结点大于 1 :当 BLOCK_SIZE 大于 1 时,每个结点存放多个字符,当最后一个结点未存满<br>时,不足处可用特定字符(如#)补齐。虽然存储密度相对结点大小等于 1 的存储方法来说,存储<br>密度较高,但此时插入、删除的处理方法比较复杂,需要考虑结点的分拆和合并。<table><tr><td bgcolor=#FFC0CB><font  size=5>块链串的结构</td></tr></table></li></ol><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLOCK_SIZE 4 <span class="hljs-comment">/*每结点存放字符个数 4*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> ch[BLOCK_SIZE];    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block</span> *<span class="hljs-title">next</span>;</span>&#125; Block;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    Block *head;    Block *tail;    <span class="hljs-keyword">int</span> len;&#125; BLString;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6>串的应用举例:简单的行编辑器</td></tr></table><p>可将文本看成为一个大的字符串,文本编辑就相当对字符串的处理。文本编辑程序用于源程序的输入和修改,公文书信、报刊和书籍的编辑排版等。常用的文本编辑程序有Edit,WPS,Word 等。文本编辑的实质是修改字符数据的形式和格式,虽然各个文本编辑程序的功能不同,但基本操作是一样的,都包括串的查找、插入和删除等。<br>为了编辑方便,可以用分页符和换行符将文本分为若干页,每页有若干行。可以把文本当作一个字符串,称为文本串,页是文本串的子串,行是页的子串。这里采用堆存储结构来存储文本,同时设立页指针、行指针和字符指针,分别指向当前操作的页、行和字符,同时建立页表和行表存储每一页、每一行的起始位置和长度。</p><ul><li>假设有如下 Pascal 源程序：<br>FUNC max(x，y：integer)：integer;<br>VAR z：integer;<br>BEGIN<br>IF x&gt;y THEN z:=x;<br>ELSE z:=y;<br>RETURN(z);<br>END;</li></ul><p>该程序输入内存后放到一个堆中，如图 4.3 所示。其中↙为换行符。表 4－1 和表 4－2 分别<br>为下图所示文本串的页表和行表。</p><p><img src="https://img-blog.csdnimg.cn/20200323152121152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由表 4 -1 、表 4 -2 可以看出,当在某行内插入字符时,就要修改行表中该行的长度,若该行的长度超出了分配给它的存储空间,则要重新给它分配存储空间,同时修改它的起始位置和长度。如果要插入或删除一行,就要进行行表的插入和删除,当行的插入和删除涉及页的变化是时要对页表进行修改。</p><table><tr><td bgcolor=#E6E6FA><font  size=6>典型题例</td></tr></table><p>要求编写一个用带头结点的单链表实现串的模式匹配算法,每个结点存放一个字符(结<br>点大小为 1 )。借助于前面的结点大小为 1 定义链串类型 LKString。<br>【问题分析】该算法类同顺序串的简单模式匹配,实现匹配过程需考虑链表的特征(从头<br>比较的技术,指针保留的技术)。<br>【算法思想】<br>①初始化：主串从start开始，模式串从头开始<br>②两串逐位比较：当主串模式串均未遍历完时，对应字符作比较<br>若相等：主串模式串的当前比较位置均后移<br>若不等：主串从开始比较位置的下一个开始，模式串从头开始<br>③判别：若匹配成功返回起始位置指针，若不成功，返回NULL<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">Link *<span class="hljs-title">StrIndex</span><span class="hljs-params">(LKString *s, LKString *t)</span></span><span class="hljs-function"><span class="hljs-comment">/* 求模式串 t 在主串 s 中第一次出现的位置指针 */</span></span><span class="hljs-function"></span>&#123;    Link *sp, *tp, *start;    <span class="hljs-keyword">if</span> (t-&gt;len == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> s-&gt;head-&gt;next; <span class="hljs-comment">/* 空串是任意串的子串 */</span>    start = s-&gt;head-&gt;next;    <span class="hljs-comment">/* 记录主串的起始比较位置 */</span>    sp = start;               <span class="hljs-comment">/* 主串从 start 开始 */</span>    tp = t-&gt;head-&gt;next;       <span class="hljs-comment">/* 模式串从第一个结点开始 */</span>    <span class="hljs-keyword">while</span> (sp != <span class="hljs-literal">NULL</span> &amp;&amp; tp != <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-keyword">if</span> (sp-&gt;ch == tp-&gt;ch) <span class="hljs-comment">/* 若当前对应字符相同，则继续比较 */</span>        &#123;            sp = sp-&gt;next;            tp = tp-&gt;next;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 发现失配字符，则返回到主串当前起始位置的下一个结点继续比较*/</span>        &#123;            start = start-&gt;next; <span class="hljs-comment">/* 更新主串的起始位置 */</span>            sp = start;            tp = t-&gt;head-&gt;next; <span class="hljs-comment">/* 模式串从第一个结点重新开始 */</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> (tp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> start; <span class="hljs-comment">/* 匹配成功，返回主串当前起始位置指针 */</span>    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 匹配不成功，返回空指针 */</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【串】串的顺序存储结构</title>
    <link href="/2020/03/23/%E3%80%90%E4%B8%B2%E3%80%91%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2020/03/23/%E3%80%90%E4%B8%B2%E3%80%91%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6>定长顺序串</td></tr></table>1.定义：定长顺序串是将串设计成一种静态结构类型,串的存储分配是在编译时完成的。与前面所讲的线性表的顺序存储结构类似,可用一组地址连续的存储单元存储串的字符序列。<table><tr><td bgcolor=#FFC0CB><font  size=5>定长顺序串存储结构</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 40 <span class="hljs-comment">/*MAXLEN 表示串的最大长度*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> ch[MAXLEN]; <span class="hljs-comment">/*ch 是存储字符串的一维数组,每个分量存储一</span><span class="hljs-comment">个字符*/</span>    <span class="hljs-keyword">int</span> len;         <span class="hljs-comment">/*len 是字符串的长度*/</span>&#125; SString;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5>定长顺序串基本操作的实现</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4> 1. 串插入函数</td></tr></table><p> 【问题分析】在进行顺序串的插入时,插入位置 pos 将串分为两部分(假设为 A、 B,长度为LA、 LB)及待插入部分(假设为 C,长度为 LC),则串由插入前的 AB 变为 ACB,由于是顺序串,插入会引起元素的移动。可能出现以下三种情况:<br>①插入后串长( LA+LC +LB)≤ MAXLEN,则将 B 后移 LC 个元素位置,再将 C 插入。<br>②插入后串长&gt;MAXLEN 且 pos+LC≤ MAXLEN,则 B 后移时会有部分字符被舍弃。<br>③插入后串长&gt; MAXLEN 且 pos +LC &gt;MAXLEN,则 B 的全部字符被舍弃(不需后移),并 且 C 在插入时也有部分字符被舍弃。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c">StrInsert(SString *s, <span class="hljs-keyword">int</span> pos, SString t)<span class="hljs-comment">/*在串 s 中下标为 pos 的字符之前插入串 t */</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt; s-&gt;len)        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <span class="hljs-comment">/*插入位置不合法*/</span>    <span class="hljs-keyword">if</span> (s-&gt;len + t.len &lt;= MAXLEN)    &#123; <span class="hljs-comment">/*插入后串长≤MAXLEN*/</span>        <span class="hljs-keyword">for</span> (i = s-&gt;len + t.len - <span class="hljs-number">1</span>; i &gt;= t.len + pos; i--)            s-&gt;ch[i] = s-&gt;ch[i - t.len];        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; t.len; i++)            s-&gt;ch[i + pos] = t.ch[i];        s-&gt;len = s-&gt;len + t.len;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pos + t.len &lt;= MAXLEN)    &#123; <span class="hljs-comment">/*插入后串长&gt;MAXLEN,但串 t 的字符序列可以全部插入*/</span>        <span class="hljs-keyword">for</span> (i = MAXLEN - <span class="hljs-number">1</span>; i &gt; t.len + pos - <span class="hljs-number">1</span>; i--)            s-&gt;ch[i] = s-&gt;ch[i - t.len];        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; t.len; i++)            s-&gt;ch[i + pos] = t.ch[i];        s-&gt;len = MAXLEN;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">/*插入后串长&gt;MAXLEN,并且串 t 的部分字符也要舍弃*/</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXLEN - pos; i++)            s-&gt;ch[i + pos] = t.ch[i];        s-&gt;len = MAXLEN;    &#125;    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);&#125;</code></pre></div><ul><li>显然,实现顺序串插入的算法其实现复杂度为: O( s-&gt;len+t.len)。<table><tr><td bgcolor=#99CCFF><font  size=4> 2. 串删除函数</td></tr></table></li></ul><div class="hljs"><pre><code class="hljs c">StrDelete(SString *s, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> l)<span class="hljs-comment">/*在串 s 中删除从下标 pos 起 l 个字符*/</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt; (s-&gt;len - l))        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <span class="hljs-comment">/*删除参数不合法*/</span>    <span class="hljs-keyword">for</span> (i = pos + l; i &lt; s-&gt;len; i++)        s-&gt;ch[i - l] = s-&gt;ch[i];    <span class="hljs-comment">/*从 pos+l 开始至串尾依次向前移动，实现删除 l 个字符*/</span>    s-&gt;len = s-&gt;len - l; <span class="hljs-comment">/*s 串长减 l*/</span>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4> 3. 串的简单模式匹配 Brute-Force(布鲁特-福斯)算法</td></tr></table><p>【算法思想】</p><blockquote><p>简单的模式匹配算法是一种带回溯的匹配算法,算法的基本思想是:从主串S 的第 pos 个字符开始,和模式串 T 的第一个字符开始比较,如果相等,就继续比较后续字符,如果不等,则从(回溯到)主串 S 的第 pos+1 个字符开始重新和模式串 T 比较,直到模式串 T 中的每一个字符和主串 S 中的一个连续字符子序列全部相等,则称匹配成功,返回和 T 中第一个字符相等的字符在主串 S 中的位置;或者主串中没有和模式串相等的字符序列,则称匹配不成功。</p></blockquote><p>【算法描述】</p><blockquote><p>实现时设 i、 j、 start 三个指示器:<br>i——指向主串 S 中当前比较的字符,起始指向 S 的首字符,此后,每比较一步,后移一步,一趟匹配失败时,回溯到该趟比较起点的下一位置。<br>j———指向子串 T 中当前比较的字符,起始指向 T 的首字符,此后,每比较一步,后移一步,一趟匹配失败时,回溯到 T 的首字符处。<br>start———记录每趟比较时在主串 S 中的起点,每趟比较后,后移一步,以便确定下一趟的起始位置。</p></blockquote><p>【算法思想】</p><blockquote><p>从主串s的pos位置起，与模式串t逐位匹配<br>①初始化：主串从pos开始，模式串从头开始<br>②两串逐位比较：当主串模式串均未遍历完时，对应字符作比较<br>若相等：主串模式串的当前比较位置均后移<br>若不等：主串从开始比较位置的下一个开始，模式串从头开始<br>③判别：若匹配成功返回起始位置，若不成功，返回-1</p></blockquote><div class="hljs"><pre><code class="hljs c">StrIndex(SString s, <span class="hljs-keyword">int</span> pos, SString t)<span class="hljs-comment">/*求从主串 s 的下标 pos 起，串 t 第一次出现的位置，成功返回位置序号，不成功返回-1*/</span>&#123;    <span class="hljs-keyword">int</span> i, j, start;    <span class="hljs-keyword">if</span> (t.len == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <span class="hljs-comment">/* 模式串为空串时，是任意串的匹配串 */</span>    start = pos;    i = start;    j = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 主串从 pos 开始，模式串从头（0）开始 */</span>    <span class="hljs-keyword">while</span> (i &lt; s.len &amp;&amp; j &lt; t.len)        <span class="hljs-keyword">if</span> (s.ch[i] == t.ch[j])        &#123;            i++;            j++;        &#125; <span class="hljs-comment">/* 当前对应字符相等时推进 */</span>        <span class="hljs-keyword">else</span>        &#123;            start++; <span class="hljs-comment">/* 当前对应字符不等时回溯 */</span>            i = start;            j = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 主串从 start+1 开始，模式串从头（0）开始*/</span>        &#125;    <span class="hljs-keyword">if</span> (j &gt;= t.len)        <span class="hljs-keyword">return</span> (start); <span class="hljs-comment">/* 匹配成功时，返回匹配起始位置 */</span>    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>); <span class="hljs-comment">/* 匹配不成功时，返回-1 */</span>&#125;</code></pre></div><p>【算法分析】</p><blockquote><p>该算法思路比较简单,但最坏时间复杂度较高,为 O( s.len* t.len),如主串为<br>51 个 0 ,模式串为 7 个 0 后有个 1 ,每趟都在最后一个不匹配后而倒到 start+1 ,整个匹配过程<br>共需 s.len- t.len=45 趟,每趟比较 t.len=8 个字符,故此例整个比较了 360 次。这个算法的主要<br>时间耗费在失配后的比较位置有回溯,造成了比较次数太多的情况。降低时间复杂度可采用<br>无回溯的算法——KMP算法<br><img src="https://img-blog.csdnimg.cn/202003231121568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200323112322433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020032311232720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></blockquote><table><tr><td bgcolor=#E6E6FA><font  size=6>堆串</td></tr></table><p>1.字符串包括串名与串值两部分,而串值采用堆串存储方法存储,串名用符号表存储。</p><ul><li>堆串存储方法:仍以一组地址连续的存储单元顺序存放串中的字符,但它们的存储空间是在程序执行过程中是动态分配的。系统将一个地址连续、容量很大的存储空间作为字符串的可用空间,每当建立一个新串时,系统就从这个空间中分配一个大小和字符串长度相同的空间存储新串的串值。</li><li>串名符号表:所有串名的存储映像构成一个符号表。借助此结构可以在串名和串值之间建立一个对应关系,称为串名的存储映像。<br><img src="https://img-blog.csdnimg.cn/20200323113029907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><table><tr><td bgcolor=#FFC0CB><font  size=5> 堆串存储结构</td></tr></table></li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> *ch; <span class="hljs-comment">/*ch 域指示串的起始地址*/</span>    <span class="hljs-keyword">int</span> len;  <span class="hljs-comment">/*len 域指示串的长度*/</span>&#125; HString;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5>堆串基本操作的实现</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4> 1. 串插入函数</td></tr></table><div class="hljs"><pre><code class="hljs c">StrInsert(HString *s，<span class="hljs-keyword">int</span> pos，HString *t)&#123; <span class="hljs-comment">/*在串 s 中下标为 pos 的字符之前插入串 t */</span>    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *temp;    <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt; s-&gt;len || s-&gt;len == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                         <span class="hljs-comment">/*插入位置不合法*/</span>    temp = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(s-&gt;len + t-&gt;len); <span class="hljs-comment">/*动态产生足够的空间存放插入后的串*/</span>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pos; i++)        temp[i] = s-&gt;ch[i];    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; t-&gt;len; i++)        temp[i + pos] = t-&gt;ch[i];    <span class="hljs-keyword">for</span> (i = pos; i &lt; s-&gt;len; i++)        temp[i + t-&gt;len] = s-&gt;ch[i];    s-&gt;len += t-&gt;len;    <span class="hljs-built_in">free</span>(s-&gt;ch);    s-&gt;ch = temp;    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4> 2. 串删除函数</td></tr></table><div class="hljs"><pre><code class="hljs c">StrDelete(HString *s，<span class="hljs-keyword">int</span> pos，<span class="hljs-keyword">int</span> len)<span class="hljs-comment">/*在串 s 中删除从下标 pos 起 len 个字符 */</span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">char</span> *temp;    <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt; (s-&gt;len - len))        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <span class="hljs-comment">/*删除参数不合法*/</span>    temp = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(s-&gt;len - len);    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pos; i++)        temp[i] = s-&gt;ch[i];    <span class="hljs-keyword">for</span> (i = pos; i &lt; s-&gt;len - len; i++)        temp[i] = s-&gt;ch[i + len];    s-&gt;len = s-&gt;len - len;    <span class="hljs-built_in">free</span>(s-&gt;ch);    s-&gt;ch = temp;    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【串】串的基本概念</title>
    <link href="/2020/03/23/%E3%80%90%E4%B8%B2%E3%80%91%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/03/23/%E3%80%90%E4%B8%B2%E3%80%91%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6> 1.串的基本概念</td></tr></table><p>字符串（String）：是由零个或多个字符组成的有限序列，记为:S = ′a1 a2 … an′( n ≥ 0 )<br>ai∈V字符集合，每个 ai( 1 ≤ i≤ n)可以是字母、数字或其他字符。<br><strong>串也是一种特定的线性表</strong>，串的逻辑结构和线性表极为相似，其特定性仅在于串的数据对象限定为字符集。</p><ol><li><strong>串的名字</strong>：S</li><li><strong>串的值</strong>：用单引号括起来的字符序列</li><li><strong>串的长度</strong>：n 是串中字符的个数</li><li><strong>空串</strong>( Null String)：n=0 时的串</li><li><strong>空格串</strong>：一个或多个空格组成的串，其长度为空格个数。</li><li><strong>串相等</strong>：当且仅当两个串的值相等时,称这两个串是相等的。即只有当两个串的长度相等,并且每个对应位置的字符都相等时才相等。<blockquote><p>需要特别指出的是,串值必须用一对单引号括起来( C 语言中是双引号),但单引号是界限符,它不属于串,其作用是避免与变量名或常量混淆。</p></blockquote></li><li><strong>子串</strong>：串中任意个连续的字符组成的子序列称为该串的子串。</li><li><strong>主串</strong>：包含子串的串相应地称为主串。可见,子串是主串的一部分。</li><li><strong>求子串</strong>：sub（主串，起始位置，长度）<br>例：sub（‘china’，2，2）=‘in’</li><li><strong>模式串在主串种的位置（串的模式匹配）</strong>：<br>从主串起始位置起，模式串在主串种首次出现的位置序号<br>例：主串‘chinachina’模式串‘in’<br>如起始位置为0，则模式串第一个字符在主串种的位置为2<br>如起始位置为3，则模式串第一个字符在主串种的位置为7<table><tr><td bgcolor=#E6E6FA><font  size=6> 2.串的抽象数据类型定义</td></tr></table></li></ol><p>ADT String {<br>数据对象: D={ ai | ai∈ CharacterSet,记为 V,i=1 ,2 ,…, n,n≥ 0 }<br>结构关系: R={&lt; ai,ai + 1 &gt;| ai,ai + 1 ∈ V,i=1 ,…, n-1 ; n-1 ≥ 0 }<br>基本操作:<br>( 1 ) StrAsign( S,chars)<br>操作前提: chars 是字符串常量。<br>操作结果:生成一个值等于 chars 的串 S。<br>( 2 ) StrInsert( S,pos,T)<br>操作前提:串 S 存在,1 ≤ pos≤ StrLength( S)+ 1 。<br>操作结果:在串 S 的第 pos 个字符之前插入串 T。<br>( 3 ) StrDelete( S,pos,len)<br>操作前提:串 S 存在,1 ≤ pos≤ StrLength( S)+ 1 。<br>操作结果:从串 S 中删除第 pos 个字符起长度为 len 的子串。<br>( 4 ) StrCopy( S,T)<br>操作前提:串 S 存在。<br>操作结果:由串 T 复制得串 S。<br>( 5 ) StrEmpty( S)<br>操作前提:串 S 存在。<br>操作结果:若串 S 为空串,则返回 TRUE,否则返回 FALSE。<br>( 6 ) StrCompare( S,T)<br>操作前提:串 S 和 T 存在。<br>操作结果:若 S&gt;T,则返回值&gt;0 ;如 S=T,则返回值=0 ;若 S&lt;T,则返回值&lt;0 。<br>( 7 ) StrLength( S)<br>操作前提:串 S 存在。<br>操作结果:返回串 S 的长度,即串 S 中的字符个数。<br>( 8 ) StrClear( S)<br>操作前提:串 S 存在。<br>操作结果:将 S 清为空串。<br>( 9 ) StrCat( S,T)<br>操作前提:串 S 和 T 存在。<br>操作结果:将串 T 的值连接在串 S 的后面。<br>( 10 ) SubString( Sub,S,pos,len)<br>操作前提:串 S 存在,1 ≤ pos≤ StrLength( S)且 1 ≤ len≤ StrLength( S)-<br>pos+1 。<br>操作结果:用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。<br>( 11 ) StrIndex( S,pos,T)<br>操作前提:串 S 和 T 存在,T 是非空串,1 ≤ pos≤ StrLength( S)。<br>操作结果:若串 S 中存在和串 T 相同的子串,则返回它在串 S 中第 pos 个字符<br>之<br>后第一次出现的位置;否则返回 0 。<br>( 12 ) StrReplace( S,T,V)<br>操作前提:串 S、 T 和 V 存在且 T 是非空串。<br>操作结果:用 V 替换串 S 中出现的所有与 T 相等的不重叠的子串。<br>( 13 ) StrDestroy( S)<br>操作前提:串 S 存在。<br>操作结果:销毁串 S。<br>}ADT string</p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【栈】栈的应用与递归</title>
    <link href="/2020/03/18/%E3%80%90%E6%A0%88%E3%80%91%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E9%80%92%E5%BD%92/"/>
    <url>/2020/03/18/%E3%80%90%E6%A0%88%E3%80%91%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6> 括号表达式</td></tr></table><p>【题目描述】<br>假设表达式中包含三种括号：圆括号、方括号和花括号，它们可互相嵌套，如 ( [ { } ] ( [ ] ) )或( { ( [ ] [ ( ) ] ) } )等均为正确的格式，而 { [ ] } ) }或 { [ ( ) ] 或 ( [ ] }均为不正确的格式。在检验算法中可设置一个栈，每读入一个括号。</p><ol><li><p>若读入左括号，则直接入栈，等待相匹配的同类右括号；</p></li><li><p>若读入右括号，且与当前栈顶的左括号同类型，则二者匹配，将栈顶的左括号出栈，否则属于不合法的情况。</p></li><li><p>另外，如果输入序列已读尽，而栈中仍有等待匹配的左括号，或者读入了一个右括号，而栈中已无等待匹配的左括号，均属不合法的情况。当输入序列和栈同时变为空时，说明所有括号完全匹配。</p><p>【算法描述】</p></li></ol><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*构造一个空栈 S*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SeqStack *S)</span> </span>&#123;S-&gt;top= <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">/*判栈空*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Isempty</span><span class="hljs-params">(SeqStack *S)</span> </span>&#123;<span class="hljs-keyword">return</span> (S-&gt;top==<span class="hljs-number">-1</span>?TRUE:FALSE);&#125;<span class="hljs-comment">/*读栈顶元素*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SeqStack *S, StackElementType *x)</span> </span>&#123; <span class="hljs-comment">/* 将栈 S 的栈顶元素弹出，放到 x 所指的存储空间中，但栈顶指针保持不变 */</span><span class="hljs-keyword">if</span>(S-&gt;top==<span class="hljs-number">-1</span>) <span class="hljs-comment">/*栈为空*/</span><span class="hljs-keyword">return</span>(FALSE);<span class="hljs-keyword">else</span> &#123;*x = S-&gt;elem[S-&gt;top];<span class="hljs-keyword">return</span>(TRUE);&#125;&#125;<span class="hljs-comment">/*出栈*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SeqStack * S, StackElementType *x)</span> </span>&#123;<span class="hljs-comment">/* 将栈 S 的栈顶元素弹出，放到 x 所指的存储空间中 */</span><span class="hljs-keyword">if</span>(S-&gt;top= =<span class="hljs-number">-1</span>) <span class="hljs-comment">/*栈为空*/</span><span class="hljs-keyword">return</span>(FALSE);<span class="hljs-keyword">else</span> &#123;*x= S-&gt;elem[S-&gt;top];S-&gt;top--; <span class="hljs-comment">/* 修改栈顶指针 */</span><span class="hljs-keyword">return</span>(TRUE);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BracketMatch</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><span class="hljs-function"><span class="hljs-comment">/* str[]中为输入的字符串，利用堆栈技术来检查该字符串中的括号是否匹配*/</span></span><span class="hljs-function"></span>&#123;Stack S;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">char</span> ch;InitStack(&amp;S);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; str[i]!=<span class="hljs-string">'\0'</span>; i++) &#123;<span class="hljs-keyword">switch</span>(str[i]) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">'['</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">'&#123;'</span>:Push(&amp;S,str[i]);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">']'</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">'&#125;'</span>:<span class="hljs-keyword">if</span>(IsEmpty(&amp;S)) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n 右括号多余!"</span>);<span class="hljs-keyword">return</span>;&#125; <span class="hljs-keyword">else</span> &#123;GetTop (&amp;S,&amp;ch);<span class="hljs-keyword">if</span>(Match(ch,str[i])) <span class="hljs-comment">/*用 Match 判断两个括号是否匹配*/</span>Pop(&amp;S,&amp;ch); <span class="hljs-comment">/*已匹配的左括号出栈*/</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n 对应的左右括号不同类!"</span>);<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;<span class="hljs-keyword">if</span>(IsEmpty(&amp;S))<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n 括号匹配!"</span>);<span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n 左括号多余!"</span>);&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6> 表达式求值</td></tr></table><p>【题目描述】<br>表达式求值是高级语言编译的一个基本问题，是栈的典型应用实例。</p><blockquote><p>任何一个表达式都是由运算数(operand)、运算符(operator)和界限符(delimiter)组成的。运算数既可以是常数，也可以是被说明为变量或常量的标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符三类；基本界限符有左右括号和表达式结束符等。仅讨论无括号算术表达式求值的求值问题。</p></blockquote><p>由于某些运算符可能具有比别的运算符更高的优先级，因此表达式求值不可能严格地从左到右进行，如下图所示，其中↑为幂运算，# 是表达式结束符，这是为运算方便引入的一个特殊符号。<br><img src="https://img-blog.csdnimg.cn/20200317081952653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>为了正确的处理表达式，使用栈来实现正确的指令序列是一个重要的技术。下面以无括号表达式为例进行说明。<br>【算法思想】<br>（1）规定运算符的优先级表<br>（2）设置两个栈：OVS(运算数栈)、OPTR(运算符栈)<br>（3）自左向右扫描，进行如下处理：<br>①遇到运算数则进 OVS 栈；<br>②遇到运算符则与 OPTR 栈的栈顶运算符进行优先级比较：</p><ul><li>如果当前运算符&gt;OPTR 栈顶运算符，则当前运算符进 OPTR 栈；</li><li>如果当前运算符≤OPTR 栈顶运算符，则 OPTR 退栈一次，得到栈顶运算符θ，OVS连续退栈两次，得到运算数 a、运算数 b，对 a，b 执行θ运算，得到结果 T(i)，将 T(i) 进OVS 栈。<br><img src="https://img-blog.csdnimg.cn/20200318084148911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><p>例 3-1 在实现 A/B↑C+D<em>E 的运算过程中，栈区变化情况如图 3.9 所示。为运算方便，<br>在表达式后面加上一个结束符#，并将其视为一个优先级最低的特殊运算符，所以实际输入<br>的表达式为：A/B↑C+D</em>E#。</p><p><img src="https://img-blog.csdnimg.cn/20200318084512294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">【算法描述】无括号算术表达式处理算法</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*构造一个空栈 S*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SeqStack *S)</span> </span>&#123;S-&gt;top= <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">/*进栈S*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(SeqStack * S, StackElementType x)</span> </span>&#123;<span class="hljs-keyword">if</span>(S-&gt;top== Stack_Size<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>(FALSE); <span class="hljs-comment">/*栈已满*/</span>S-&gt;top++;S-&gt;elem[S-&gt;top]=x;<span class="hljs-keyword">return</span>(TRUE);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SeqStack *S, StackElementType *x)</span> </span>&#123; <span class="hljs-comment">/* 将栈 S 的栈顶元素弹出，放到 x 所指的存储空间中，但栈顶指针保持不变 */</span><span class="hljs-keyword">if</span>(S-&gt;top==<span class="hljs-number">-1</span>) <span class="hljs-comment">/*栈为空*/</span><span class="hljs-keyword">return</span>(FALSE);<span class="hljs-keyword">else</span> &#123;*x = S-&gt;elem[S-&gt;top];<span class="hljs-keyword">return</span>(TRUE);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SeqStack * S, StackElementType *x)</span> </span>&#123;<span class="hljs-comment">/* 将栈 S 的栈顶元素弹出，放到 x 所指的存储空间中 */</span><span class="hljs-keyword">if</span>(S-&gt;top= =<span class="hljs-number">-1</span>) <span class="hljs-comment">/*栈为空*/</span><span class="hljs-keyword">return</span>(FALSE);<span class="hljs-keyword">else</span> &#123;*x= S-&gt;elem[S-&gt;top];S-&gt;top--; <span class="hljs-comment">/* 修改栈顶指针 */</span><span class="hljs-keyword">return</span>(TRUE);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ExpEvaluation</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-comment">/*读入一个简单算术表达式并计算其值。</span></span><span class="hljs-function"><span class="hljs-comment">operator 和 operand 分别为运算符栈和运算数栈，</span></span><span class="hljs-function"><span class="hljs-comment">OPS 为运算符集合*/</span></span><span class="hljs-function"></span>&#123;InitStack(&amp;operand);InitStack(&amp;<span class="hljs-keyword">operator</span>);Push(&amp;<span class="hljs-keyword">operator</span>,<span class="hljs-string">'#'</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\nPlease input an expression (Ending with #) :"</span>);ch=getchar();<span class="hljs-keyword">while</span>(ch!=<span class="hljs-string">'#'</span>||GetTop(<span class="hljs-keyword">operator</span>)!=<span class="hljs-string">'#'</span>) &#123; <span class="hljs-comment">/* GetTop()通过函数值返回栈顶元素*/</span><span class="hljs-keyword">if</span>(!In(ch,OPS)) &#123; <span class="hljs-comment">/*不是操作符，是操作数*/</span>n=GetNumber(ch);push(&amp;operand,n);&#125; <span class="hljs-keyword">else</span><span class="hljs-keyword">switch</span>(Compare(ch, GetTop(<span class="hljs-keyword">operator</span>))) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;'</span>:Push(&amp;<span class="hljs-keyword">operator</span>,ch);ch=getchar();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'='</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;'</span>:Pop(&amp;<span class="hljs-keyword">operator</span>,&amp;op);Pop(&amp;operand,&amp;b);Pop(&amp;operand,&amp;a);v=Execute(a,op,b); <span class="hljs-comment">/* 对 a 和 b 进行 op 运算 */</span>Push(&amp;operand,v);<span class="hljs-keyword">break</span>;&#125;&#125;v=GetTop(operand);<span class="hljs-keyword">return</span> (v);&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6> 栈与递归</td></tr></table><p> <strong>递归</strong>是指在定义自身的同时又出现了对自身的引用。</p><ul><li><p>如果一个函数在其定义体内直接调用自己，则称为直接递归函数</p></li><li><p>如果一个函数经过一系列的中间调用语句，通过其他函数间接调用自己，则称为间接递归函数</p><p>（1）递归定义的数学函数<br><img src="https://img-blog.csdnimg.cn/20200318090542540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>上述 Ackerman 函数可用一个简单的 C 语言函数描述如下：</p></li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ack(m<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ack(m<span class="hljs-number">-1</span>, ack(m,n<span class="hljs-number">-1</span>));&#125;</code></pre></div><p>（2）递归数据结构的处理<br>在后续章节将要学习的一些数据结构，如广义表、二叉树、树等结构其本身均具有固有的递归特性，因此可以自然地采用递归法进行处理。<br>（3）递归求解方法<br>许多问题的求解过程可以用递归分解的方法描述，一个典型的例子是著名的汉诺塔问题（Hanoi）问题。<br>n 阶 Hanoi 塔问题：假设有三个分别命名为 X,Y 和 Z 的塔座，在塔座 X 上插有 n 个直径大小各不相同、从小到大编号为 1，2,… ，n 的圆盘。现要求将塔座 X 上的 n 个圆盘移至塔座 Z 上，并仍按同样顺序叠排。圆盘移动时必须遵循下列规则：<br>① 每次只能移动一个圆盘；<br>② 圆盘可以插在 X,Y 和 Z 中的任何一个塔座上；<br>③ 任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。</p><blockquote><p>【算法思想】当 n=1 时，问题比较简单，只要将编号为 1 的圆盘从座 X 直接移动到塔座 Z 上即可；当 n&gt;1 时，需利用塔座 Y 作辅助塔座，若能设法将压在编号为 n 的圆盘上的 n-1 个圆盘从塔座 X(依照上述原则)移至塔座 Y 上，则可先将编号为 n 的圆盘从塔座 X 移至塔座 Z 上，然后再将塔座 Y 上的 n-1 个圆盘(依照上述原则)移至塔座 Z 上。而如何将 n-1 个圆盘从一个塔座移至另一个塔座问题是一个和原问题具有相同特征属性的问题，只是问题的规模小于 1，因此可以用同样方法求解。由此可得如下求解 n 阶 Hanoi 塔问题的递归算法。</p></blockquote><p>【算法描述】 算法 3.14 汉诺塔递归算法</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> x, <span class="hljs-keyword">char</span> y, <span class="hljs-keyword">char</span> z)</span></span><span class="hljs-function"><span class="hljs-comment">/* 将塔座 X 上从上到下编号为 1 至 n，且按直径由小到大叠放的 n 个圆盘，按</span></span><span class="hljs-function"><span class="hljs-comment">规则搬到塔座 Z 上，Y 用作辅助塔座。*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-built_in">move</span>(x, <span class="hljs-number">1</span>, z); <span class="hljs-comment">/*将编号为 1 的圆盘从 x 移动 z*/</span><span class="hljs-keyword">else</span>&#123;hanoi(n - <span class="hljs-number">1</span>, x, z, y); <span class="hljs-comment">/* 将 X 上编号为 1 至 n-1 的圆盘移到 y,z 作辅助</span><span class="hljs-comment">塔 */</span><span class="hljs-built_in">move</span>(x, n, z); <span class="hljs-comment">/* 将编号为 n 的圆盘从 x 移到 z */</span>hanoi(n - <span class="hljs-number">1</span>, y, x, z); <span class="hljs-comment">/* 将 y 上编号为 1 至 n-1 的圆盘移到 z，x 作辅</span><span class="hljs-comment">助塔 */</span>&#125;&#125;</code></pre></div><ul><li><p>设计递归算法的方法<br>递归算法就是在算法中直接或间接调用算法本身的算法。使用递归算法的前提有两个：<br>⑴原问题可以层层分解为类似的的子问题，且子问题比原问题的规模更小。<br>⑵规模最小的子问题具有直接解。</p></li><li><p>设计递归算法的原则是用自身的简单情况来定义自身，设计递归算法的方法是：<br>⑴寻找分解方法：将原问题转化为子问题求解。（ 例：n!=n*(n-1)! ）<br>⑵设计递归出口：即根据规模最小的子问题，确定递归终止条件。（例：求解 n!时，当 n=1 时，n!=1）。</p></li><li><p>递归过程的实现<br>递归进层（i→i +1 层）系统需要做三件事：<br>⑴ 保留本层参数与返回地址；<br>⑵ 为被调用函数的局部变量分配存储区，给下层参数赋值；<br>⑶ 将程序转移到被调函数的入口。<br>而从被调用函数返回调用函数之前，递归退层（i←i +1 层）系统也应完成<br>三件工作：<br>⑴ 保存被调函数的计算结果；<br>⑵ 释放被调函数的数据区，恢复上层参数；<br>⑶ 依照被调函数保存的返回地址，将控制转移回调用函数。<br><img src="https://img-blog.csdnimg.cn/2020032307390516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200323073908942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=6> 递归与非递归转换</td></tr></table></li><li><p>简单递归的消除<br>①单向递归<br>单向递归是指递归函数中虽然有一处以上的递归调用语句，但各次递归调用语句的参数只和主调用函数有关，相互之间参数无关，并且这些递归调用语句处于算法的最后。<br>计算斐波那契数列的递归算法 Fib(n) 是单向递归的一个典型例子。</p></li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> n;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-1</span>)+fib(n<span class="hljs-number">-2</span>);&#125;</code></pre></div><blockquote><p>用循环方式计算 Fib(n)时，Fib(i) (i=2…n)是在已计算过 Fib (i-1)与 Fib (i-2)的基础上进行的，无重复计算，时间复杂度为 O(n)。虽然非递归算法没有递归算法直观，但时空耗费远少于递归算法。<br>而用递归方式计算 Fib (n)时，必须计算 Fib (n-1)与 Fib (n-2)，而某次递归计算得出的结果，如 Fib (3)无法保存，下一次要用到时还需要重新递归计算，因此其时间复杂度为 O(2n)。</p></blockquote><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-comment">/*计算 Fib (0)或 Fib(1) */</span>    <span class="hljs-keyword">int</span> x,y,z;    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>|n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;    <span class="hljs-keyword">else</span>&#123;        x=<span class="hljs-number">0</span>,y=<span class="hljs-number">1</span>;<span class="hljs-comment">/* x= Fib (0) y= Fib (1) */</span>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;            z=y;<span class="hljs-comment">/* z= Fib (i-1) */</span>            y=x+y;<span class="hljs-comment">/* y= Fib (i-1)+ Fib (i-2) 求 Fib (i) */</span>            x=z;<span class="hljs-comment">/* x= Fib (i-1) */</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> y;&#125;</code></pre></div><ul><li>②尾递归<br>尾递归是指递归调用语句只有一个，而且是处于算法的最后，尾递归是单向递归的特例。<br>以阶乘问题的递归算法 Fact(n)为例讨论尾递归算法的运行过程，算法如下：</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">Fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-keyword">if</span>(n= =<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> n*Fact(n<span class="hljs-number">-1</span>);&#125;</code></pre></div><p>对于尾递归形式的递归算法，不必利用系统的运行时栈保存各种信息。尾递归形式的算法实际上可变成循环结构的算法。循环结构的阶乘问题算法 Fact(n)如下：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">Fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> fac = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">/*依次计算 f(1)… f(n)*/</span>    &#123;        fac = fac * i;<span class="hljs-comment">/* f(i)= f(i-1)*i */</span>    &#125;    <span class="hljs-keyword">return</span> fac;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【栈】链栈及其基本操作</title>
    <link href="/2020/03/17/%E3%80%90%E6%A0%88%E3%80%91%E9%93%BE%E6%A0%88%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/03/17/%E3%80%90%E6%A0%88%E3%80%91%E9%93%BE%E6%A0%88%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6> 栈的链式实现</td></tr></table>1.定义：链栈即采用链表作为存储结构实现的栈。为便于操作，这里采用带头结点的单链表实现栈。<ul><li>top 为栈顶指针，始终指向当前栈顶元素前面的头结点。</li><li>若 top-&gt;next=NULL，则代表栈空。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200317062405987.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>采用链栈不必预先估计栈的最大容量，只要系统有可用空间，链栈就不会出现溢出。采用链栈时，栈的各种基本操作的实现与单链表的操作类似，对于链栈，在使用完毕时，应该释放其空间。</p></blockquote><table><tr><td bgcolor=#FFC0CB><font  size=5> c语言描述顺序栈</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>StackElementType data;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>&#125; LinkStackNode;<span class="hljs-keyword">typedef</span> LinkStackNode *LinkStack;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 链栈基本操作的实现</td></tr></table><table><tr><td bgcolor=    #FFF0F5><font  size=4> 1.进栈</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack top, StackElementType x)</span></span><span class="hljs-function"><span class="hljs-comment">/* 将数据元素 x 压入栈 top 中 */</span></span><span class="hljs-function"></span>&#123;LinkStackNode * temp;temp=(LinkStackNode * )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkStackNode));<span class="hljs-keyword">if</span>(temp==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>(FALSE); <span class="hljs-comment">/* 申请空间失败 */</span>temp-&gt;data=x;temp-&gt;next=top-&gt;next;top-&gt;next=temp; <span class="hljs-comment">/* 修改当前栈顶指针 */</span><span class="hljs-keyword">return</span>(TRUE);&#125;</code></pre></div><table><tr><td bgcolor=    #FFF0F5><font  size=4> 2.出栈</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack top, StackElementType *x)</span> </span>&#123;<span class="hljs-comment">/* 将栈 top 的栈顶元素弹出，放到 x 所指的存储空间中 */</span>LinkStackNode * temp;temp=top-&gt;next;<span class="hljs-keyword">if</span>(temp==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">/*栈为空*/</span><span class="hljs-keyword">return</span>(FALSE);top-&gt;next=temp-&gt;next;*x=temp-&gt;data;<span class="hljs-built_in">free</span>(temp); <span class="hljs-comment">/* 释放存储空间 */</span><span class="hljs-keyword">return</span>(TRUE);&#125;</code></pre></div><table><tr><td bgcolor=#FFE1FF><font  size=6>多栈运算</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200317063634826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【栈】顺序栈及其基本操作和应用[两栈共享]</title>
    <link href="/2020/03/17/%E3%80%90%E6%A0%88%E3%80%91%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BA%94%E7%94%A8%5B%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%5D/"/>
    <url>/2020/03/17/%E3%80%90%E6%A0%88%E3%80%91%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BA%94%E7%94%A8%5B%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%5D/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6> 栈的顺序实现</td></tr></table><p>1.定义</p><ul><li>利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素</li><li>设一个位置指示器 top（栈顶指针）来动态地指示栈顶元素在顺序栈中的位置。</li><li>通常以 top=-1 表示空栈。（=0的时候是栈中第一个元素）<table><tr><td bgcolor=#FFC0CB><font  size=5> c语言描述顺序栈</td></tr></table></li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 1 </span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> stack_size 50 </span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>StackElementType elem[stack_size];<span class="hljs-comment">/*用来存放栈中元素的一维数组*/</span><span class="hljs-keyword">int</span> top;<span class="hljs-comment">/*用来存放栈顶元素的下标，top 为-1 表示空栈*/</span>&#125;seqstack;</code></pre></div><blockquote><p>StackElementType   栈元素类型</p></blockquote><table><tr><td bgcolor=#FFC0CB><font  size=5> 顺序栈基本操作的实现</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4>1.初始化</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*构造一个空栈 S*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SeqStack *S)</span> </span>&#123;S-&gt;top= <span class="hljs-number">-1</span>;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>2.判栈空</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Isempty</span><span class="hljs-params">(SeqStack *S)</span> </span>&#123;<span class="hljs-keyword">return</span> (S-&gt;top==<span class="hljs-number">-1</span>?TRUE:FALSE);&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>3.判栈满</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Isfull</span><span class="hljs-params">(SeqStack *S)</span> </span>&#123;<span class="hljs-keyword">return</span> (S-&gt;top==stack_size<span class="hljs-number">-1</span>?TRUE:FALSE);&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>4.进栈</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(SeqStack * S, StackElementType x)</span> </span>&#123;<span class="hljs-keyword">if</span>(S-&gt;top== Stack_Size<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>(FALSE); <span class="hljs-comment">/*栈已满*/</span>S-&gt;top++;S-&gt;elem[S-&gt;top]=x;<span class="hljs-keyword">return</span>(TRUE);&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>5.出栈</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SeqStack * S, StackElementType *x)</span> </span>&#123;<span class="hljs-comment">/* 将栈 S 的栈顶元素弹出，放到 x 所指的存储空间中 */</span><span class="hljs-keyword">if</span>(S-&gt;top= =<span class="hljs-number">-1</span>) <span class="hljs-comment">/*栈为空*/</span><span class="hljs-keyword">return</span>(FALSE);<span class="hljs-keyword">else</span> &#123;*x= S-&gt;elem[S-&gt;top];S-&gt;top--; <span class="hljs-comment">/* 修改栈顶指针 */</span><span class="hljs-keyword">return</span>(TRUE);&#125;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>6.读栈顶元素</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SeqStack *S, StackElementType *x)</span> </span>&#123; <span class="hljs-comment">/* 将栈 S 的栈顶元素弹出，放到 x 所指的存储空间中，但栈顶指针保持不变 */</span><span class="hljs-keyword">if</span>(S-&gt;top==<span class="hljs-number">-1</span>) <span class="hljs-comment">/*栈为空*/</span><span class="hljs-keyword">return</span>(FALSE);<span class="hljs-keyword">else</span> &#123;*x = S-&gt;elem[S-&gt;top];<span class="hljs-keyword">return</span>(TRUE);&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 两栈共享</td></tr></table><blockquote><p>若使用顺序栈，会因为对栈空间大小难以准确估计，从而产生有的栈溢出、有的栈空间还很空闲的情况。为了解决这个问题，可以让多个栈共享一个足够大的数组空间，通过利用栈的动态特性来使其存储空间互相补充，这就是多栈共享技术。</p></blockquote><p>在顺序栈的共享技术中最常用的是两个栈的共享技术即双端栈：</p><ul><li>它主要利用了栈<strong>栈底位置不变，而栈顶位置动态变化</strong>的特性。</li><li>首先为两个栈申请一个共享的一维数组空间 S[M]</li><li>将两个栈的栈底分别放在一维数组的两端，分别是 0，M-1。<br><img src="https://img-blog.csdnimg.cn/20200316065755979.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><table><tr><td bgcolor=#EED2EE><font  size=4> 两栈共享的数据结构定义</td></tr></table></li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>StackElementType Stack[M];<span class="hljs-keyword">int</span>  top[<span class="hljs-number">2</span>]; <span class="hljs-comment">/*top[0]和 top[1]分别为两个栈顶指示器*/</span>&#125; DqStack;</code></pre></div><table><tr><td bgcolor=#EED2EE><font  size=4> 初始化</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(DqStack *S)</span> </span>&#123;S-&gt;top[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;S-&gt;top[<span class="hljs-number">1</span>]=M;&#125;</code></pre></div><table><tr><td bgcolor=#EED2EE><font  size=4> 进栈</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Push</span><span class="hljs-params">(DqStack *S, StackElementType x, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-comment">/*把数据元素 x 压入 i 号堆栈*/</span><span class="hljs-keyword">if</span>(S-&gt;top[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>==S-&gt;top[<span class="hljs-number">1</span>]) <span class="hljs-comment">/*栈已满*/</span><span class="hljs-keyword">return</span>(FALSE);<span class="hljs-keyword">switch</span>(i) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:S-&gt;top[<span class="hljs-number">0</span>]++;S-&gt;Stack[S-&gt;top[<span class="hljs-number">0</span>]]=x;Stack:<span class="hljs-number">0</span> M<span class="hljs-number">-1</span>top[<span class="hljs-number">0</span>] top[<span class="hljs-number">1</span>]<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:S-&gt;top[<span class="hljs-number">1</span>]--;S-&gt;Stack[S-&gt;top[<span class="hljs-number">1</span>]]=x;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>: <span class="hljs-comment">/*参数错误*/</span><span class="hljs-keyword">return</span>(FALSE)&#125;<span class="hljs-keyword">return</span>(TRUE);&#125;</code></pre></div><table><tr><td bgcolor=#EED2EE><font  size=4> 出栈</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(DqStack *S, StackElementType *x, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-comment">/* 从 i 号堆栈中弹出栈顶元素并送到 x 中 */</span><span class="hljs-keyword">switch</span>(i) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-keyword">if</span>(S-&gt;top[<span class="hljs-number">0</span>]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>(FALSE);*x=S-&gt;Stack[S-&gt;top[<span class="hljs-number">0</span>]];S-&gt;top[<span class="hljs-number">0</span>]--;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">if</span>(S-&gt;top[<span class="hljs-number">1</span>]==M) <span class="hljs-keyword">return</span>(FALSE);*x=S-&gt;Stack[S-&gt;top[<span class="hljs-number">1</span>]];S-&gt;top[<span class="hljs-number">1</span>]++;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span>(FALSE);&#125;<span class="hljs-keyword">return</span>(TRUE);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【栈】栈的定义</title>
    <link href="/2020/03/16/%E3%80%90%E6%A0%88%E3%80%91%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <url>/2020/03/16/%E3%80%90%E6%A0%88%E3%80%91%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6> 栈的定义</td></tr></table><ol><li>栈作为一种<strong>限定性线性表</strong>，是将线性表的插入和删除运算限制为仅在表的一端进行。</li><li>栈顶：通常将表中允许进行插入、删除操作的一端称为栈顶 (Top)</li><li>栈底：同时表的另一端被称为栈底 (Bottom)</li><li>栈顶指示器：用来指示动态变化的栈顶位置。</li><li>空栈：当栈中没有元素时称为空栈。</li><li>满栈：无法申请到栈区可用空间。</li><li>栈的常见运算：栈的插入操作被形象地称为进栈或入栈，删除操作称为出栈或退栈。</li><li>上溢：栈已满还要入栈。</li><li>下溢：栈已空还要出栈。</li><li>栈的特性：后进先出。（LIFO）</li></ol><blockquote><p>根据上述定义，每次进栈的元素都被放在原栈顶元素之上而成为新的栈顶，而每次出栈的总是当前栈中“最新”的元素，即最后进栈的元素。在下图所示的栈中，元素是以 a1，a2，a3，…，an 的顺序进栈的，而退栈的次序却是 an，…，a3，a2，a1。栈的修改是按<strong>后进先出</strong>的原则进行的。因此，栈又称为后进先出的线性表，简称为 LIFO 表。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200316061549274.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200316062110424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ol start="11"><li>栈的抽象数据类型定义。<br>ADT Stack<br>数据元素：可以是任意类型的数据，但必须属于同一个数据对象。<br>结构关系：栈中数据元素之间是线性关系。<br>基本操作：<br>（1） InitStack(S)<br>操作前提：S 为未初始化的栈。<br>操作结果：将 S 初始化为空栈。<br>（2） ClearStack(S)<br>操作前提：栈 S 已经存在。<br>操作结果：将栈 S 置成空栈。<br>（3） IsEmpty(S)<br>操作前提：栈 S 已经存在。<br>操作结果：判栈空函数，若 S 为空栈则函数值为“TRUE”，否则为“FALSE”。<br>（4） IsFull(S)<br>操作前提：栈 S 已 经存在。<br>操作结果：判栈满函数，若 S 栈已满，则函数值为“TRUE”，否则为“FALSE”。<br>（5） Push(S,x)<br>操作前提：栈 S 已经存在。<br>操作结果：在 S 的顶部插入(亦称压入)元素 x；若 S 栈未满，将 x 插入栈顶<br>位置，若栈已满，则返回 FALSE，表示操作失败，否则返回 TRUE。<br>（6） Pop(S, x)<br>操作前提：栈 S 已经存在。<br>操作结果：删除(亦称弹出)栈 S 的顶部元素，并用 x 带回该值；<br>若栈为空，返回值为 FALSE，表示操作失败，否则返回 TRUE。<br>（7） GetTop(S, x)<br>操作前提：栈 S 已经存在。<br>操作结果：取栈 S 的顶部元素赋给 x 所指向的单元。与 Pop(S, x)不同之处在<br>于 GetTop(S,x)不改变栈顶的位置。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】顺序表与链表的综合比较</title>
    <link href="/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%BC%E5%90%88%E6%AF%94%E8%BE%83/"/>
    <url>/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%BC%E5%90%88%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<p>&lt;———————————–西北大学mooc摘要————————————-&gt;<br> 1.基于空间的考虑<br>顺序表的存储空间是静态分配的，在程序执行之前必须明确规定它的存储规模。若线性表的长度 n 变化较大，则存储规模难于预先确定。估计过大将造成空间浪费，估计太小又将使空间溢出的机会增多。<br>在静态链表中，初始存储池虽然也是静态分配的，但若同时存在若干个结点类型相同的链表，则它们可以共享空间，使各链表之间能够相互调节余缺，减少溢出机会。动态链表的存储空间是动态分配的，只要内存空间尚有空闲，就不会产生溢出。<br>因此，当线性表的长度变化较大，难以估计其存储规模时，采用动态链表作为存储结构较好。</p><p><strong>存储密度</strong>(Storage Density)是指结点数据本身所占的存储量和整个结点结构所占的存储量之比，即：存储密度=结点数据本身所占的存储量/结点结构所占的存储总量链表中的每个结点，除了数据域外，还要额外设置指针（或游标）域，从存储密度来讲，这是不经济的。</p><p>一般地，存储密度越大，存储空间的利用率就高。显然，顺序表的存储密度<br>为 1，而链表的存储密度小于 1。例如单链表的结点的数据均为整数，指针所占空间和整型量相同，则单链表的存储密度为 50%。因此若不考虑顺序表的备用结点空间，则顺序表的存储空间利用率为 100%，而单链表的存储空间利用率为50%。由此可知，当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。</p><p>2.基于时间的考虑<br>顺序表是由向量实现的，它是一种随机存取结构，对表中任一结点都可以在<br>O (1) 时间内直接地存取，而链表中的结点，需从头指针起顺着链找才能取得。因此，若线性表的操作主要是进行查找，很少做插入和删除时，宜采用顺序表做存储结构。<br>在链表中的任何位置上进行插入和删除，都只需要修改指针。而在顺序表中<br>进行插入和删除，平均要移动表中近一半的结点，尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。因此，对于频繁进行插入和删除的线性表，宜采用链表做存储结构。若表的插入和删除主要发生在表的首尾两端，则宜采用尾指针表示的单循环链表。</p><p>3.基于语言的考虑<br>在没有提供指针类型的高级语言环镜中，若要采用链表结构，则可以使用光<br>标实现的静态链表。虽然静态链表在存储分配上有不足之处，但它是和动态链表一样，具有插入和删除方便的特点。<br>值得指出的是，即使是对那些具有指针类型的语言，静态链表也有其用武之<br>地。特别是当线性表的长度不变，仅需改变结点之间的相对关系时，静态链表比动态链表可能更方便。<br><img src="https://img-blog.csdnimg.cn/20200315062959831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】应用—一元多项式的表示及相加</title>
    <link href="/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%BA%94%E7%94%A8%E2%80%94%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E7%9B%B8%E5%8A%A0/"/>
    <url>/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%BA%94%E7%94%A8%E2%80%94%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%8A%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[ <table><tr><td bgcolor=#E6E6FA><font  size=5>  1. 一元多项式的表示</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200315052630347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br> <table><tr><td bgcolor=#E6E6FA><font  size=5>   2. 一元多项式的存储</td></tr></table></p><p> 一元多项式的操作可以利用线性表来处理。因此，一元多项式也有顺序存储和链式存储两种方法。<br> <img src="https://img-blog.csdnimg.cn/20200315052909253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020031505304063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>结点结构体定义如下</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">polynode</span>&#123;</span><span class="hljs-keyword">int</span> coef;<span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>;polynode *next;&#125;polynode,polylist;</code></pre></div> <table><tr><td bgcolor=#E6E6FA><font  size=5>   例：建立一元多项式链式存储算法</td></tr></table><p>【算法思想】通过键盘输入一组多项式的系数和指数，用尾插法建立一元多项式的链表。以输入系数0为结束标注，并约定建立多项式链表时，总是按指数从小到大排序。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">polylist <span class="hljs-title">polycreate</span><span class="hljs-params">()</span> </span>&#123;polynode *head,*rear,*s;<span class="hljs-keyword">int</span> c,e;head=(polynode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(polynode));<span class="hljs-comment">//建立多项式的头结点；</span>rear=head;<span class="hljs-comment">//rear始终指向单链表的尾，便于尾插法建表</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>,&amp;c,&amp;e);<span class="hljs-comment">//键入多项式的系数和指数项</span><span class="hljs-keyword">while</span>(c!=<span class="hljs-number">0</span>)<span class="hljs-comment">//若c=0，则代表多项式的输入结束</span>&#123;s=(polynode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(polynode));<span class="hljs-comment">//申请新的结点</span>s-&gt;coef=c;s-&gt;<span class="hljs-built_in">exp</span>=e;rear-&gt;next=s;<span class="hljs-comment">//在当前表尾做插入 </span>rear=s; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>,&amp;c,&amp;e);&#125;rear-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//将表的最后一个结点的next置NULL，以表示结束</span><span class="hljs-keyword">return</span> (head); &#125;</code></pre></div> <table><tr><td bgcolor=#E6E6FA><font  size=5>  3. 一元多项式的相加运算</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200315054815361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>【算法思想】<br>以单链表polya和polyb分别表示两个一元多项式A和B，A+B的求和运算，就等同于单链表的插入问题（将单链表polyb中的结点插入到单链表polya中），因此“和多项式”中的结点无需另生成。<br>为实现处理，设p，q分别指向单链表polya和polyb的当前项，比较p，q的结点的指数项，由此得到下列运算规则：<br>①若p-&gt;exp &lt; q-&gt;exp，则结点p所指的结点应该是“和多项式”中的一项，另指针后移；</p><p>②若p-&gt;exp = q-&gt;exp，则将两个结点中的系数增加，当和不为零时修改结点p的系数域，释放q结点；若和为零，则和多项式中无此项，从A中删去p结点，同时释放p和q结点。</p><p>③若p-&gt;exp &gt; q-&gt;exp，则结点q所指的结点应该时“和多项式”中的一项，将结点q插入结点p之前，且令指针q在原来的链表上后移</p><p>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">polyadd</span><span class="hljs-params">(polylist polya,polylist polyb)</span></span><span class="hljs-function"><span class="hljs-comment">//将两个多项式相加，然后将和多项式存放在polya中，并将polyb删除</span></span><span class="hljs-function"></span>&#123;polynode *p,*q,*tail,*temp;<span class="hljs-keyword">int</span> sum;p=polya-&gt;next;q=polyb-&gt;next;<span class="hljs-comment">//令p和q分别指向polya和polyb多项式链表中的第一个结点</span>tail=polya;<span class="hljs-comment">//tail指向和多项式的尾结点</span><span class="hljs-comment">/*-----初始化(略)-----*/</span><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;q!=<span class="hljs-literal">NULL</span>) &#123;<span class="hljs-keyword">if</span>(p-&gt;<span class="hljs-built_in">exp</span>&lt;q-&gt;<span class="hljs-built_in">exp</span>)<span class="hljs-comment">//规则（1）：如果p指向的多项式的指数小于q的指数，将p结点加入到和多项式中</span>&#123;tail-&gt;next=p;tail=p;p=p-&gt;next;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;<span class="hljs-built_in">exp</span>==q-&gt;<span class="hljs-built_in">exp</span>)<span class="hljs-comment">//规则(2)：若指数相等，则相应的系数相加</span>&#123;sum=p-&gt;coef+q-&gt;coef;<span class="hljs-keyword">if</span>(sum!=<span class="hljs-number">0</span>)<span class="hljs-comment">//若系数和非0，则系数和置入结点p，释放结点q，并将指针后移</span>&#123;p-&gt;coef=sum;tail-&gt;next=p;tail=p;p=p-&gt;next;temp=q;q=q-&gt;next;<span class="hljs-built_in">free</span>(temp);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//若系数和为0.删除p，q，并将指针指向下一个结点</span>temp=p;p=p-&gt;next;<span class="hljs-built_in">free</span>(temp);temp=q;q=q-&gt;next;<span class="hljs-built_in">free</span>(temp);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">////规则（3）：如果p指向的多项式的指数大于q的指数，将q结点加入到和多项式中</span>tail-&gt;next=q;tail=q;q=q-&gt;next;&#125;&#125;<span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//多项式A中还有剩余，则将剩余的结点加入到和多项式中</span>&#123;tail-&gt;next=p;tail=p;p=p-&gt;next;&#125; <span class="hljs-keyword">else</span> &#123;tail-&gt;next=q;tail=q;q=-&gt;next;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】循环双向静态链表</title>
    <link href="/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%BE%AA%E7%8E%AF.%E5%8F%8C%E5%90%91.%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/03/15/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%BE%AA%E7%8E%AF.%E5%8F%8C%E5%90%91.%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#E6E6FA><font  size=6> 循环链表</td></tr></table><ol><li>定义：首尾相接的链表</li><li>结构：尾结点的指针域指向头结点或表的首元结点</li><li>特点：表中所有结点都链接在一个环上</li><li>判断循环链表空链表的条件：头指针的指针域指向自己（head-&gt;next==head）<table><tr><td bgcolor=#FFC0CB><font  size=5> 循环链表的合并算法</td></tr></table></li></ol><p>算法思路：</p><ol><li>遍历两表找表尾</li><li>将第一表尾链接第二表头，将第二表尾链接第一表头 </li></ol><p><img src="https://img-blog.csdnimg.cn/20200311210658984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">linklist <span class="hljs-title">merge_1</span><span class="hljs-params">(linklist la,linklist lb)</span></span>&#123;<span class="hljs-comment">/*将两个采用头指针的循环单链表的首尾连接起来*/</span>node *p,*q;p=la;q=lb;<span class="hljs-keyword">while</span>(p-&gt;next!=la) p=p-&gt;next;<span class="hljs-comment">/*找到表la的表尾，用p指向它*/</span><span class="hljs-keyword">while</span>(q-&gt;next!=lb) q=q-&gt;next;<span class="hljs-comment">/*找到表lb的表尾，用p指向它*/</span>q-&gt;next=la;<span class="hljs-comment">/*修改表lb的尾指针，使之指向表la的头结点*/</span>p-&gt;next=lb-&gt;next;<span class="hljs-comment">/*修改表la的尾指针，使之指向表lb的第一个结点*/</span><span class="hljs-built_in">free</span>(lb);<span class="hljs-keyword">return</span>(la);&#125;</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200311210706579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">linklist <span class="hljs-title">merge_2</span><span class="hljs-params">(linklist ra,linklist rb)</span></span>&#123;<span class="hljs-comment">/*将两个采用尾指针的循环单链表的首尾连接起来*/</span>node *p;p=ra-&gt;next;<span class="hljs-comment">/*保存链表ra的头结点的地址*/</span>ra-&gt;next=rb-&gt;next-&gt;next;<span class="hljs-comment">/*链表rb的开始接待你链到链表ra的终端结点之后*/</span><span class="hljs-built_in">free</span>(rb-&gt;next);rb-&gt;next=p;<span class="hljs-comment">/*链表ra的头结点链到链表rb 的终端节点之后*/</span><span class="hljs-keyword">return</span> rb;<span class="hljs-comment">/*返回新循环链表的尾指针*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6>双向链表</td></tr></table><ol><li><p>定义：链表中每个结点增加一个指向其前驱的指针。每个结点包含两个指针域</p></li><li><p>特点：任一结点均可沿前驱和后继两个方向操作。<br><img src="https://img-blog.csdnimg.cn/20200312051202800.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#FFC0CB><font  size=6>c语言结构定义</td></tr></table></li></ol><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dnode</span>&#123;</span>elemtype data;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dnode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span>&#125;dnode,*doublelist;</code></pre></div> <table><tr><td bgcolor=#FFC0CB><font  size=6> 操作</td></tr></table> <table><tr><td bgcolor=#99CCFF><font  size=4>1.前插操作 </td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200313040255210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dlinkins</span><span class="hljs-params">(doublelist l,<span class="hljs-keyword">int</span> i,elemtype e)</span></span>&#123;dnode *p,*s;<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;p=l;<span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;(i))<span class="hljs-comment">/*在第i个元素之前插入，则先找到第i个数据元素的存储位置</span><span class="hljs-comment">使p指针指向它*/</span>&#123;p=p-&gt;next;k++; &#125;<span class="hljs-keyword">if</span>(!p)<span class="hljs-comment">/*如果当前位置p为空，表示已找完但还未数到第i个</span><span class="hljs-comment">说明插入位置不合理*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置不合理"</span>);<span class="hljs-keyword">return</span> error; &#125;s=(dnode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(dnode));<span class="hljs-comment">/*为s申请一个新结点并由s指向它*/</span><span class="hljs-keyword">if</span>(s)&#123;s-&gt;data=e;s-&gt;prior=p-&gt;prior;<span class="hljs-comment">//① </span>p-&gt;prior-&gt;next=s;<span class="hljs-comment">//② </span>s-&gt;next=p;<span class="hljs-comment">//③ </span>p-&gt;prior=s;<span class="hljs-comment">//④ </span><span class="hljs-keyword">return</span> TRUE;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE; &#125;</code></pre></div>  <table><tr><td bgcolor=#99CCFF><font  size=4>2.删除操作 </td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200313040713676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dlinkdel</span><span class="hljs-params">(doublelist l,<span class="hljs-keyword">int</span> i,elemtype *e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在双向链表中删除第i个元素，</span></span><span class="hljs-function"><span class="hljs-comment">并将删除的元素保存到变量*e中。*/</span></span><span class="hljs-function"></span>&#123;dnode *p;<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;p=l;<span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;(i))<span class="hljs-comment">/*寻找被删除结点i使p指向它*/</span>&#123;p=p-&gt;next;k++;&#125;<span class="hljs-keyword">if</span>(k!=i)<span class="hljs-comment">/*即循环是因为p-&gt;next=NULL而跳出来的*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除位置i不合理"</span>);<span class="hljs-keyword">return</span> error;&#125;*e=p-&gt;data;p-&gt;prior-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=p-&gt;prior;<span class="hljs-built_in">free</span>(p);<span class="hljs-comment">/*释放被删除结点所占内存空间*/</span><span class="hljs-keyword">return</span> TRUE;&#125;</code></pre></div> <table><tr><td bgcolor=#FFC0CB><font  size=5> 双向循环列表</td></tr></table><p><img src="https://img-blog.csdnimg.cn/20200313042242567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><table><tr><td bgcolor=#E6E6FA><font  size=6>静态链表</td></tr></table> <table><tr><td bgcolor=#FFC0CB><font  size=4> 静态链表的基本特征</td></tr></table><ol><li>存储池：定义一个较大的<strong>结构数组</strong>作为备用结点空间</li><li>游标机制：每个结点应该应该含有两个域，data域和next（或者cursor）域。<ul><li>data域用来存放结点的数据信息。</li><li>cuisor域为游标指示器，指示<strong>后继结点在结构数组中的相对位置</strong>（即<strong>数组下标值</strong>）数组的第0个分量可以设计成表的头结点，头结点的cursor域指示了表中第一个结点的位置，cursor值为0表示静态单链表结束。</li></ul></li><li>结点结构<div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxsize <span class="hljs-comment">//链表可能达到的最大长度</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>elemtype data;<span class="hljs-keyword">int</span> <span class="hljs-built_in">cursor</span>;&#125; component,staticlist[maxsize];</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=4>静态链表的插入和删除操作示例</td></tr></table></li></ol><p><img src="https://img-blog.csdnimg.cn/20200313044655434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>插入：</p><ul><li>step1：申请一个空闲空间并置入元素 e，即：使 S[9].data=e</li><li>step2：修改第四个元素的游标域，将 e 插入到链表中。即：S[9].cursor= S[4].cursor，S[4].cursor=9。</li></ul><p>删除：</p><ul><li>若要删除第 8 个元素 h，则先顺着游标链通过记数找到第 7 个元素存储位置 6，令 S[6].cursor=S[7].cursor。</li></ul><p>缺点 ：</p><ul><li>上述例子中未考虑对已释放空间的回收，这样在经过多次插入和删除后，会造成静态链表的“假满”。即表中有很多的空闲空间，但却无法再插入元素。造成这种现象的原因是未对已删除的元素所占的空间进行回收。</li></ul><p>解决方法：</p><ul><li>将所有未被分配的结点空间以及因删除操作而回收的结点空间用游标 链成一个备用静态链表。</li><li>当进行插入操作时，先从备用链表上取一个分量来存放待插入的元素，然后将其插入到已用链表的相应位置。</li><li>当进行删除操作时，则将被删除的结点空间链接到备用链表上以备后用。</li><li>这种方法是指在已申请的大的存储空间中有一个已用的静态单链表，还有一个备用单链表。已用静态单链表的头指针为 0，备用静态单链表的头指针需另设一个变量 av 来表示。</li></ul><table><tr><td bgcolor=#FFC0CB><font  size=6> 基本操作</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=4>1.初始化 </td></tr></table>  算法描述：初始化为一个备用静态单链表。<p><img src="https://img-blog.csdnimg.cn/20200313050122667.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>ps：这里的maxsize=11</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">(straticlist space,<span class="hljs-keyword">int</span> *av)</span></span><span class="hljs-function"><span class="hljs-comment">/*构建两个表，已用空间为空表，其余空间为备用空间表*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> k;space[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">cursor</span>=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;(maxsize<span class="hljs-number">-1</span>);k++)&#123;space[k]-&gt;<span class="hljs-built_in">cursor</span>=k+<span class="hljs-number">1</span>&#125; space[maxsize<span class="hljs-number">-1</span>]=<span class="hljs-number">-1</span>;*av=<span class="hljs-number">1</span>;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=4>2.分配结点 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*从可用区申请新结点*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnode</span> <span class="hljs-params">(staticlis space, <span class="hljs-keyword">int</span> *av)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i;i=*av;*av=space[av].<span class="hljs-built_in">cursor</span>;<span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回可用新结点i </span>&#125;</code></pre></div><ul><li>对系统而言，相当于备用链表中减少一个结点 i。</li><li>对使用者而言，相当于申请得到了一个可用的新结点 i。</li></ul><table><tr><td bgcolor=#99CCFF><font  size=4>3.结点回收 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*备用区回收空闲节点*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freenode</span><span class="hljs-params">(staticlist space,<span class="hljs-keyword">int</span> *av,<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"><span class="hljs-comment">//增加一个新结点k</span></span><span class="hljs-function"></span>&#123;spcae[k].<span class="hljs-built_in">cursor</span>=*av;*av=k;&#125;</code></pre></div><ul><li>对系统而言，回收空闲结点相当于备用链表中增加一个结点 k。</li><li>对使用者而言，相当于释放了一个不用的结点 k。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>习题11-8 单链表结点删除</title>
    <link href="/2020/03/14/%E4%B9%A0%E9%A2%9811-8%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4/"/>
    <url>/2020/03/14/%E4%B9%A0%E9%A2%9811-8%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<p> 本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中所有存储了某给定值的结点删除。</p><div class="hljs"><pre><code>链表结点定义如下：</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span>    <span class="hljs-keyword">int</span> data;    ListNode *next;&#125;;</code></pre></div><div class="hljs"><pre><code>函数接口定义：</code></pre></div><blockquote><p>struct ListNode *readlist();<br>struct ListNode *deletem( struct ListNode *L, int m );</p></blockquote><p>函数readlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。<br>函数deletem将单链表L中所有存储了m的结点删除。返回指向结果链表头结点的指针。</p><div class="hljs"><pre><code>裁判测试程序样例：</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span>    <span class="hljs-keyword">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">next</span>;</span>&#125;;<span class="hljs-function">struct ListNode *<span class="hljs-title">readlist</span><span class="hljs-params">()</span></span>;<span class="hljs-function">struct ListNode *<span class="hljs-title">deletem</span><span class="hljs-params">( struct ListNode *L, <span class="hljs-keyword">int</span> m )</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printlist</span><span class="hljs-params">( struct ListNode *L )</span></span><span class="hljs-function"></span>&#123;     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p</span> = <span class="hljs-title">L</span>;</span>     <span class="hljs-keyword">while</span> (p) &#123;           <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, p-&gt;data);           p = p-&gt;next;     &#125;     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">L</span> = <span class="hljs-title">readlist</span>();</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);    L = deletem(L, m);    printlist(L);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="hljs"><pre><code>输入样例：10 11 10 12 10 -1         10输出样例：11 12 </code></pre></div><p>答案：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">struct ListNode *<span class="hljs-title">readlist</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//读入一系列正整数，按照读入顺序建立单链表。</span><span class="hljs-keyword">int</span> c,flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//检查输入是否正确</span><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;c);<span class="hljs-comment">/*建立表头*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">l</span>;</span>l=(struct ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct ListNode));<span class="hljs-keyword">if</span>(c!=(<span class="hljs-number">-1</span>))&#123;l-&gt;data=c;             l-&gt;next=<span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*尾插法建表*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">r</span>;</span>r=l;<span class="hljs-comment">/*r始终动态地指向表尾,初值指向头结点*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">n</span>;</span><span class="hljs-keyword">while</span>(flag) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;c);<span class="hljs-keyword">if</span>(c!=(<span class="hljs-number">-1</span>)) &#123;n=(struct ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct ListNode));n-&gt;data=c;n-&gt;next=<span class="hljs-literal">NULL</span>;r-&gt;next=n;r=n;<span class="hljs-comment">//r就是当前尾结点</span>&#125; <span class="hljs-keyword">else</span> &#123;r-&gt;next=<span class="hljs-literal">NULL</span>;flag=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-function">struct ListNode *<span class="hljs-title">deletem</span><span class="hljs-params">( struct ListNode *L, <span class="hljs-keyword">int</span> m )</span> </span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">h</span>,*<span class="hljs-title">p</span>,*<span class="hljs-title">q</span>;</span>h=L;<span class="hljs-comment">//先保证头结点不是m</span><span class="hljs-keyword">while</span>(h-&gt;data==m&amp;&amp;(h-&gt;next!=<span class="hljs-literal">NULL</span>)) &#123;p=h-&gt;next;<span class="hljs-built_in">free</span>(h);h=p;&#125;<span class="hljs-comment">//如果整个链表都删没了，返回NULL </span><span class="hljs-keyword">if</span>(h-&gt;data==m)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">//删除符合条件的结点</span>p=h;q=p-&gt;next;<span class="hljs-keyword">while</span>(q) &#123;<span class="hljs-keyword">if</span>(q-&gt;data==m) &#123;p-&gt;next=q-&gt;next;<span class="hljs-built_in">free</span>(q);q=p-&gt;next;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> &#123;p=q;q=q-&gt;next;&#125;&#125;<span class="hljs-keyword">return</span> h;&#125;</code></pre></div><blockquote><p>一点小小的流水账吧，纪念一下第一道和数据结构有关的题哈哈哈，我真的很菜。这道题断断续续竟然做了六个多小时…就很离谱，气的眼泪都要掉出来了。写出来其实没有多久，只是一直钻牛角尖想改自己的代码，也看不进去别人写的正确答案。<br>大一之前都没接触过编程，大一上加寒假因为各种nt事浪费了很多时间。过去种种真的很想放下说重新开始，但真的比别人差太多了，实名菜狗弟弟，没办法原谅这样的自己。<br>这段时间早上四点起来听网课敲代码记笔记，不断反省，其实也是强迫症地焦虑，甚至条件反射到不管晚上睡不睡得着早上四点都要起来学习，导致午睡根本起不来，最近只能下午狂喝黑咖＋中高强度运动避免午睡改掉这个辣鸡作息，争取稳定在晚十点半早四点半到五点。<br>还考虑了很久保研/考研/就业的事，学高数/线代/离散/大物/通信真的有压榨我敲代码的时间，但是又不想成绩不好看，毕竟还想拼一拼奖学金x包括还在打辩论，三月份是无差别比赛，就在明天开始抽签，寒假拿了个网辩季军回来还是有点小高兴的哈哈哈虽然和技术没啥关系x。还在准备六级的事，争取大一下就过六级。<br>虽然记录流水账的时候看起来很欢快，但是我永远不会忘记这个春天。如果这二十天的焦虑，痛苦，强迫和抑郁的心情是努力的敲门砖，那我愿意也舍得去尝试，希望，哦不是一定，度过这段日子之后要长长久久地坚持。<br>偷偷努力，要来证明我的选择是对的，而这一切都是-<br>我  值  得。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>PTA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】单链表及其基本运算和应用</title>
    <link href="/2020/03/11/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <url>/2020/03/11/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#99CCFF><font  size=5> 单链表的c语言定义</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>ElemType data;<span class="hljs-comment">/*数据域*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">/*指针域*/</span>&#125; Node,*Linklist;<span class="hljs-comment">/*给node起两个别名，这两个别名等效*/</span>LinkLIst L;<span class="hljs-comment">/*L为单链表的头指针，也称为单链表L*/</span></code></pre></div><p>LinkList 与 Node*同为结构指针类斜体样式型，这两种类型是等价的。</p><p>通常我们习惯上用LinkList说明指针变量，强调它是某个单链表的头指针变量，用<br>Node*来定义指向单链表中节点的指针。</p><table><tr><td bgcolor=#E6E6FA><font  size=6> 单链表的基本运算</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=5> 一、求带头节点单链表的长度</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listlength</span><span class="hljs-params">(linklist L)</span></span>&#123;node *p;p=-&gt;next;j=<span class="hljs-number">0</span>;<span class="hljs-comment">/*用来存放单链表的长度*/</span><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;p=p-&gt;next;j++;&#125;<span class="hljs-keyword">return</span> j;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=6> 二、建表</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=5>1.建立空表 </td></tr></table><div class="hljs"><pre><code class="hljs c">InitList(linklist *L)<span class="hljs-comment">/*建立空表*/</span>&#123;L=(linklist*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));L-&gt;next=<span class="hljs-literal">NULL</span>;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>2.头插法建表 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">linklist <span class="hljs-title">creatfromhead</span><span class="hljs-params">(linklist l)</span></span>&#123;node *s;<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<span class="hljs-comment">/*设置一个标志，初值为1，当输入“$”时，flag为0，建表结束*/</span><span class="hljs-keyword">while</span>(flag)&#123;c=getchar();<span class="hljs-keyword">if</span>(c!=<span class="hljs-string">'$'</span>)&#123;s(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node))<span class="hljs-comment">/*申请新结点s*/</span>s-&gt;data=c;s-&gt;next=L-&gt;next;<span class="hljs-comment">/*将结点s头插入链表L*/</span>L-&gt;next=s; &#125;<span class="hljs-keyword">else</span> flag=<span class="hljs-number">0</span>;&#125;&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>3.尾插法建表 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">linklist <span class="hljs-title">createfromtail</span><span class="hljs-params">(linklist L)</span></span>&#123;linklist L;node *r,*s;<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<span class="hljs-comment">/*设置一个标志，初值为1，当输入“$”时，flag为0，建表结束*/</span>r=L;<span class="hljs-comment">/*r指针始终动态指向链表的当前表尾，以便做尾插入，其初值指向头结点*/</span><span class="hljs-keyword">while</span>(flag)&#123;c=getchar();<span class="hljs-keyword">if</span>(c!=<span class="hljs-string">'$'</span>)&#123;s=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));s-&gt;data=c;r-&gt;next=s;r=s;<span class="hljs-comment">/*r就是当前尾结点*/</span>&#125; <span class="hljs-keyword">else</span>&#123;flag=<span class="hljs-number">0</span>;r-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*将最后一个结点的next链域置为空，表示链表结束*/</span>&#125;&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=6> 三、查找</td></tr></table><table><tr><td bgcolor=#99CCFF><font  size=5>1.按序号查找 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">node *<span class="hljs-title">get</span><span class="hljs-params">(linklist L,<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"><span class="hljs-comment">/*在带头结点的单链表L中查找第i个结点，</span></span><span class="hljs-function"><span class="hljs-comment">若找到(1&lt;=i&lt;=n),则返回该结点的存储位置，否则返回NULL*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<span class="hljs-comment">/*计数器*/</span>node *p;p=L;<span class="hljs-comment">/*从头结点开始扫描*/</span><span class="hljs-keyword">while</span>((p-&gt;next!=<span class="hljs-literal">NULL</span>)&amp;&amp;(j&lt;i))&#123;p=p-&gt;next;<span class="hljs-comment">/*扫描下一结点*/</span>j++;<span class="hljs-comment">/*已扫描结点计数器*/</span>&#125;<span class="hljs-keyword">if</span>(i==j)<span class="hljs-keyword">return</span> p;<span class="hljs-comment">/*找到了第i个点*/</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*找不到，i&lt;=0或i&gt;n*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#99CCFF><font  size=5>2.按值查找 </td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function">node *<span class="hljs-title">locate</span><span class="hljs-params">(linklist l,elemtype key)</span></span><span class="hljs-function"><span class="hljs-comment">/*在带头结点的单链表L中查找其结点值等于key的结点，</span></span><span class="hljs-function"><span class="hljs-comment">若是找到则返回该结点的位置p，否则返回NULL*/</span></span><span class="hljs-function"></span>&#123;node *p;p=l-&gt;next;<span class="hljs-comment">/*从表中第一个结点比较*/</span><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">if</span>(p-&gt;data!=key)p=p-&gt;next;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-comment">/*找到结点key退出循环*/</span>&#125; <span class="hljs-keyword">return</span> p; &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 四、单链表插入</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inslist</span><span class="hljs-params">(linklist L,<span class="hljs-keyword">int</span> i,elemtype e)</span></span>&#123;node *pre,*s;<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;pre=L;<span class="hljs-keyword">while</span>(pre!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;(i<span class="hljs-number">-1</span>))<span class="hljs-comment">/*在第i个元素之前插入，则先找到第i-1个数据元素的存储位置</span><span class="hljs-comment">使pre指针指向它*/</span>&#123;pre=pre-&gt;next;k++; &#125;<span class="hljs-keyword">if</span>(!pre)<span class="hljs-comment">/*如果当前位置pre为空，表示已找完但还未数到第i个</span><span class="hljs-comment">说明插入位置不合理*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置不合理"</span>);<span class="hljs-keyword">return</span> ERROR; &#125;s=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<span class="hljs-comment">/*为s申请一个新结点并由s指向它*/</span>s-&gt;data=e;<span class="hljs-comment">/*将待插入结点的值e赋给s的数据域*/</span>s-&gt;next=pre-&gt;next;<span class="hljs-comment">/*完成插入操作*/</span>pre-&gt;next=s;<span class="hljs-keyword">return</span> OK; &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 五、单链表删除</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dellist</span><span class="hljs-params">(linklist L,<span class="hljs-keyword">int</span> i,elemtype *e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在带头结点的单链表L中删除第i个元素，</span></span><span class="hljs-function"><span class="hljs-comment">并将删除的元素保存到变量*e中。*/</span></span><span class="hljs-function"></span>&#123;node *p,*r;<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;p=L;<span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;k&lt;(i<span class="hljs-number">-1</span>))<span class="hljs-comment">/*寻找被删除结点i的前驱结点i-1使p指向它*/</span>&#123;p=p-&gt;next;k++; &#125;<span class="hljs-keyword">if</span>(k!=i<span class="hljs-number">-1</span>)<span class="hljs-comment">/*即循环是因为p-&gt;next=NULL而跳出来的*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除位置i不合理"</span>);<span class="hljs-keyword">return</span> error; &#125;r=p-&gt;next;p-&gt;next=p-&gt;next-&gt;next;*e=r-&gt;data;<span class="hljs-built_in">free</span>(r);<span class="hljs-comment">/*释放被删除结点所占内存空间*/</span>&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6> 算法应用示例</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=4> 求两个集合的差</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">difference</span><span class="hljs-params">(linklist la,linklist lb)</span> </span>&#123;node *pre,*p,*q,*r;pre=la;p=la-&gt;next;<span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*逐个确定A表一个元素*/</span>q=lb-&gt;next;<span class="hljs-comment">/*查是否属于b表*/</span><span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>&amp;&amp;q-&gt;data!=p-&gt;data) &#123;q=q&gt;next;&#125;<span class="hljs-keyword">if</span>(q!=<span class="hljs-literal">NULL</span>) &#123;r=p;pre-&gt;next=p-&gt;next;p=p-&gt;next;<span class="hljs-built_in">free</span>(r);&#125; <span class="hljs-keyword">else</span> &#123;pre=p;p=p-&gt;next;&#125;&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=4> 带头结点单链表就地逆置问题</td></tr></table>【问题分析】逆置就是使得表中内容由原来的（a1,a2,…，ai-1，ai，ai+1， …，an）变为（an,an-1,…，ai+1，ai，ai-1， …，a1）。就地逆置就是不需要额外申请结点空间，只需要利用原有的表中的节点空间。若对顺序表中的元素进行逆置，可以借助于“交换”前后相应元素；对单链表中的元素进行逆置，则不能按“交换”思路，因为对于链表中第 i 个结点需要顺链查找第 n-i+1(链表长度为 n)个结点，逆置链表的时间复杂度将达 O（n2）。<p>【算法思路】用头插法完成</p><ul><li>【初始化】逆置链表L初始为空表，指针p指向原表当前处理结点</li><li>【头插法】依次取原链表中当前结点p<br>将其作为第一个结点插入到逆置链表L的表头L<br>q为保存原链表当前结点的下一个处理位置</li></ul><p><img src="https://img-blog.csdnimg.cn/20200315094339761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2NTEyOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverselist</span><span class="hljs-params">(linklist l)</span></span><span class="hljs-function"><span class="hljs-comment">//逆置带头结点的单链表L </span></span><span class="hljs-function"></span>&#123;p=l-&gt;next;<span class="hljs-comment">//记录原表第一个元素结点的地址 </span>l-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//从将头结点的next域置空得新空链表</span><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;q=p-&gt;next;<span class="hljs-comment">/*q 指针保留原链表当前处理结点的下一个结点*/</span>p-&gt;next=l-&gt;next;l-&gt;next=p;<span class="hljs-comment">/*p 指向下一个待插入的结点*/</span>p=q;<span class="hljs-comment">/*p 指向下一个待插入的结点*/</span>&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=4> 二进制数加一运算</td></tr></table><blockquote><p>建立一个带头结点的线性链表，用以存放输入的二进制数，链表中每个结点的<br>data 域存放一个二进制位。并在此链表上实现对二进制数加 1 的运算</p></blockquote><p>【问题分析】<br>①建链表：带二进制数可用带头结点的单链表存储，第一个结点存储二进制数的最高位，依次存储，最后一个结点存储二进制数的最低位。<br><strong>②二进制加法规则</strong>：实现二进制数加 1 运算，方向从低位往高位找到第一个值为 0 的位，把该位改成1，其后所有各位改成0<br><img src="https://img-blog.csdnimg.cn/20200315092153438.png" srcset="/img/loading.gif" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200315092207164.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>③链表实现二进制加 1 时，从高位往低位与运算方向正好相反，从第一个结点开始找，找出最后一个值域为 0 的结点，把该结点值域赋为 1，其后所有结点的值域赋为 0。</p><p>④若在链表中未找到值域为 0 的结点，则表示该二进制数各位均为 1，此时，申请一新结点，值域为 1，插入到头结点与原链表的第一个结点之间，成为新链表的第一个结点，其后所有结点的值域赋为 0。</p><p>【算法描述】</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">binadd</span><span class="hljs-params">(linklist l)</span> </span>&#123;node *q,*r,*s;q=l-&gt;next;r=l;<span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//找到最后一个值域为0的点</span>&#123;<span class="hljs-keyword">if</span>(q-&gt;data==<span class="hljs-number">0</span>) r=q;q=q-&gt;nest;&#125;<span class="hljs-keyword">if</span>(r!=l) <span class="hljs-comment">//能够找到值域为0的点</span>&#123;r-&gt;data=<span class="hljs-number">1</span>;<span class="hljs-comment">/*将最后一个值域为 0 的结点的值域赋为 1*/</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//该二进制数各位均为 1</span>&#123; s=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<span class="hljs-comment">/*申请新结点存放最高进位*/</span>s-&gt;data=<span class="hljs-number">1</span>;<span class="hljs-comment">/*值域赋为 1*/</span>s-&gt;next=l-&gt;nest;l-&gt;nest=s;<span class="hljs-comment">/*插入到头结点之后*/</span>r=s;&#125;r=r-&gt;nest;<span class="hljs-keyword">while</span>(r!=<span class="hljs-literal">NULL</span>) <span class="hljs-comment">/*将后面的所有结点的值域赋为 0*/</span>&#123; r-&gt;data=<span class="hljs-number">0</span>;r=r-&gt;nest;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】顺序表及其基本运算和应用</title>
    <link href="/2020/03/01/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2020/03/01/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#99CCFF><font  size=5> 顺序存储结构的c语言描述</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100<span class="hljs-comment">/*此处的宏定义常量表示线性表可能达到的最大长度*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>ElemType elem[MAXSIZE];<span class="hljs-comment">/*线性表占用的数组空间*/</span><span class="hljs-keyword">int</span> last;<span class="hljs-comment">/*记录线性表中最后一个元素在数组elem[]中的位置（下标值），</span><span class="hljs-comment">空表置为-1*/</span> &#125;SeqList;</code></pre></div><blockquote><p>在C语言数据结构中，关于数据元素的类型定义均用“ ElemType e；”来表示，其中e是表示数据元素的变量，而ElemType则是它的类型，ElemType的含义就是“数据元素的类型”，是一个抽象的概念，是表示我们所要使用的数据元素应有的类型。<br>ElemType是数据结构上为了说明问题而用的一个词。它是element type（“元素的类型”）的简化体。因为数据结构是讨论抽象的数据结构和算法，一种结构中元素的类型不一定是整型、字符型、浮点型或者用户自定义类型，为了不重复说明，使用过程用 “elemtype” 代表所有可能的数据类型，简单明了的概括整体。<br>在算法中，除特别说明外，规定ElemType的默认是int型。</p></blockquote><table><tr><td bgcolor=#E6E6FA><font  size=6> 顺序表的基本运算</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=5> 一、按值查找</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Locate</span><span class="hljs-params">(SeqList L ,ElemType e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中依次存放着线性表中的元素，</span></span><span class="hljs-function"><span class="hljs-comment">在表中查找到与e相等的元素，</span></span><span class="hljs-function"><span class="hljs-comment">若L[i]=e则找到该元素，并返回i的数值</span></span><span class="hljs-function"><span class="hljs-comment">若找不到，则返回“-1”*/</span></span><span class="hljs-function"></span>&#123;i=<span class="hljs-number">0</span>;<span class="hljs-comment">/*i为扫描计数器，初始值为0，即从第一个元素开始比较*/</span><span class="hljs-keyword">while</span>((i&lt;L.last)&amp;&amp;(L.elem[i]!=e))&#123;i++;<span class="hljs-comment">/*顺序扫描表，直到找到值为e的元素或扫描到表尾而没找到*/</span>&#125; <span class="hljs-keyword">if</span>(i&lt;=L.last)<span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>);<span class="hljs-comment">/*若找到，则返回其序号*/</span> <span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<span class="hljs-comment">/*若没找到，则返回空序号*/</span>  &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 二、插入</td></tr></table><p><em>其实是移动部分的代码</em></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsList</span><span class="hljs-params">(SeqList *L,<span class="hljs-keyword">int</span> i,ElemType e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中第i个元素之前插入一个元素e</span></span><span class="hljs-function"><span class="hljs-comment">表长n=L-&gt;last+1，</span></span><span class="hljs-function"><span class="hljs-comment">i的合法取值范围是1&lt;=i&lt;=L&lt;last+2*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> k;<span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L-&gt;last+<span class="hljs-number">2</span>))<span class="hljs-comment">/*首先判断插入位置是否合法*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置i值不合法"</span>);<span class="hljs-keyword">return</span> (ERROR);&#125; <span class="hljs-keyword">if</span>(L-&gt;last&gt;=maxsize<span class="hljs-number">-1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"表已满无法插入"</span>);<span class="hljs-keyword">return</span> (ERROR);&#125;<span class="hljs-keyword">for</span>(k=L-&gt;last;k&gt;=i<span class="hljs-number">-1</span>;k--)<span class="hljs-comment">/*为插入元素而移动位置*/</span>&#123;L-&gt;elem[k+<span class="hljs-number">1</span>]=L-&gt;elem[k];&#125;L-&gt;elem[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">/*在c语言中，第i个元素的下标为i-1*/</span>L-&gt;last++;<span class="hljs-keyword">return</span> (OK); &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 三、删除</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Locate</span><span class="hljs-params">(SeqList *L ,<span class="hljs-keyword">int</span> i,ElemType *e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中删除第i个数据，并用指针参数e返回其值</span></span><span class="hljs-function"><span class="hljs-comment">i的合法取值为1&lt;=i&lt;=L.last+1*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> k;<span class="hljs-keyword">while</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L-&gt;last+<span class="hljs-number">1</span>)) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除位置不合法！"</span>);<span class="hljs-keyword">return</span>(error);&#125;*e=L-&gt;elem[i<span class="hljs-number">-1</span>]<span class="hljs-comment">/*将删除的元素存放到e所指的变量中*/</span><span class="hljs-keyword">for</span>(k=i; k&lt;=L-&gt;last; k++) &#123;L-&gt;elem[k<span class="hljs-number">-1</span>]=L-&gt;elem[k];<span class="hljs-comment">/*将后面的元素依次前移*/</span>L-&gt;last--;<span class="hljs-keyword">return</span> (ok);&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 四、有序表合并</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(SeqList *LA,SeqList *LB,SeqList *LC)</span> </span>&#123;<span class="hljs-keyword">int</span> i,j,k,l;i=<span class="hljs-number">0</span>;j=<span class="hljs-number">0</span>;k=<span class="hljs-number">0</span>;<span class="hljs-comment">/*LC 为空表,设LC表的指示器k=0.</span><span class="hljs-comment">设两个指示器 i,j 分别指向表 LA 和 LB 的当前位置，初值均为 0*/</span><span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last&amp;&amp;j&lt;=LB-&gt;last) &#123;<span class="hljs-keyword">if</span>(LA-&gt;elem[i]&lt;=LB-&gt;elem[j]) &#123;LC-&gt;elem[k]=LA-&gt;elem[i];i++;k++;&#125; <span class="hljs-keyword">else</span> &#123;LC-&gt;elem[k]=LB-&gt;elem[j];j++;k++;&#125;&#125;<span class="hljs-comment">/*：LA 表和 LB 表的当前元素比较，小的元素进 LC 表，且该表的指</span><span class="hljs-comment">示器和 LC 表的指示器 k 均加 1 移向下一个位置。如此下去，直到 LA 或 LB 表</span><span class="hljs-comment">中一个表处理完毕为止。*/</span><span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last) &#123; <span class="hljs-comment">/*当表LA比表LB长时，则将表LA余下的元素赋给表LC*/</span>LC-&gt;elem[k]=LA-&gt;elem[i];i++;k++;&#125;<span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last) &#123; <span class="hljs-comment">/*当表LB比表LA长时，则将表LB余下的元素赋给表LC*/</span>LC-&gt;elem[k]=LB-&gt;elem[j];j++;k++;&#125;LC-&gt;last=LA-&gt;last+LB-&gt;last+<span class="hljs-number">1</span>;&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6> 算法应用示例</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=4> 分解顺序表为奇偶两部分</td></tr></table><blockquote><p>已知顺序表 L 中的数据元素类型为 int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为 O(n)，空间复杂度为 O（1）。</p></blockquote><p>【问题分析】<br>初见此题，可能会想到额外申请 1 个顺序表空间，之后依次从顺序表 L 中选<br>择奇数放入新表前部分，选择偶数放在新表的后半部分。但是题目要求空间复杂度为 O(1),很显然上述方法是不可行的。既然要求空间复杂度为 O(1)，说明只能借助 1 个辅助空间。</p><p>分析题目要求，其实只需要将位于表左半部分的偶数与位于表右半部分的奇数通过一个辅助变量进行交换即可，为此可以设置两个位置指示器 i 和 j,i 初值为 0，j 初值为 L-&gt;last。<br>当L-&gt;elem[i]为偶数，L-&gt;elem[j]为奇数时，则将 L-&gt;elem[i] 与 L-&gt;elem[j]交换；否则，L-&gt;elem[i]为奇数,i++, L-&gt;elem[j]为偶数，j++。这样既可以保证算法的时间复杂度为 O(n),亦可保证空间复杂度为 O（1）。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c">adjustsqlist(seqlist *l)&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=l-&gt;last,t;<span class="hljs-keyword">while</span>(i&lt;j)&#123;<span class="hljs-keyword">while</span>(l-&gt;elem[i]%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<span class="hljs-comment">/*从表的左半部分开始检测，若为奇数，则 i 加 1,直到找到偶数为止*/</span>i++;<span class="hljs-keyword">while</span>(l-&gt;elem[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">/*从表的左半部分开始检测，若为偶数，则 j 减 1,直到找到奇数为止*/</span>j--;<span class="hljs-keyword">if</span>(i&lt;j)&#123;t=l-&gt;elem[i];l-&gt;elem[i]=l-&gt;elem[j];l-&gt;elem[j]=t;&#125; &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【线性表】顺序表及其基本运算和应用</title>
    <link href="/2020/03/01/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8%20/"/>
    <url>/2020/03/01/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%BA%94%E7%94%A8%20/</url>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor=#99CCFF><font  size=5> 顺序存储结构的c语言描述</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100<span class="hljs-comment">/*此处的宏定义常量表示线性表可能达到的最大长度*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>ElemType elem[MAXSIZE];<span class="hljs-comment">/*线性表占用的数组空间*/</span><span class="hljs-keyword">int</span> last;<span class="hljs-comment">/*记录线性表中最后一个元素在数组elem[]中的位置（下标值），</span><span class="hljs-comment">空表置为-1*/</span> &#125;SeqList;</code></pre></div><blockquote><p>在C语言数据结构中，关于数据元素的类型定义均用“ ElemType e；”来表示，其中e是表示数据元素的变量，而ElemType则是它的类型，ElemType的含义就是“数据元素的类型”，是一个抽象的概念，是表示我们所要使用的数据元素应有的类型。<br>ElemType是数据结构上为了说明问题而用的一个词。它是element type（“元素的类型”）的简化体。因为数据结构是讨论抽象的数据结构和算法，一种结构中元素的类型不一定是整型、字符型、浮点型或者用户自定义类型，为了不重复说明，使用过程用 “elemtype” 代表所有可能的数据类型，简单明了的概括整体。<br>在算法中，除特别说明外，规定ElemType的默认是int型。</p></blockquote><table><tr><td bgcolor=#E6E6FA><font  size=6> 顺序表的基本运算</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=5> 一、按值查找</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Locate</span><span class="hljs-params">(SeqList L ,ElemType e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中依次存放着线性表中的元素，</span></span><span class="hljs-function"><span class="hljs-comment">在表中查找到与e相等的元素，</span></span><span class="hljs-function"><span class="hljs-comment">若L[i]=e则找到该元素，并返回i的数值</span></span><span class="hljs-function"><span class="hljs-comment">若找不到，则返回“-1”*/</span></span><span class="hljs-function"></span>&#123;i=<span class="hljs-number">0</span>;<span class="hljs-comment">/*i为扫描计数器，初始值为0，即从第一个元素开始比较*/</span><span class="hljs-keyword">while</span>((i&lt;L.last)&amp;&amp;(L.elem[i]!=e))&#123;i++;<span class="hljs-comment">/*顺序扫描表，直到找到值为e的元素或扫描到表尾而没找到*/</span>&#125; <span class="hljs-keyword">if</span>(i&lt;=L.last)<span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>);<span class="hljs-comment">/*若找到，则返回其序号*/</span> <span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<span class="hljs-comment">/*若没找到，则返回空序号*/</span>  &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 二、插入</td></tr></table><p><em>其实是移动部分的代码</em></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsList</span><span class="hljs-params">(SeqList *L,<span class="hljs-keyword">int</span> i,ElemType e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中第i个元素之前插入一个元素e</span></span><span class="hljs-function"><span class="hljs-comment">表长n=L-&gt;last+1，</span></span><span class="hljs-function"><span class="hljs-comment">i的合法取值范围是1&lt;=i&lt;=L&lt;last+2*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> k;<span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L-&gt;last+<span class="hljs-number">2</span>))<span class="hljs-comment">/*首先判断插入位置是否合法*/</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"插入位置i值不合法"</span>);<span class="hljs-keyword">return</span> (ERROR);&#125; <span class="hljs-keyword">if</span>(L-&gt;last&gt;=maxsize<span class="hljs-number">-1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"表已满无法插入"</span>);<span class="hljs-keyword">return</span> (ERROR);&#125;<span class="hljs-keyword">for</span>(k=L-&gt;last;k&gt;=i<span class="hljs-number">-1</span>;k--)<span class="hljs-comment">/*为插入元素而移动位置*/</span>&#123;L-&gt;elem[k+<span class="hljs-number">1</span>]=L-&gt;elem[k];&#125;L-&gt;elem[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">/*在c语言中，第i个元素的下标为i-1*/</span>L-&gt;last++;<span class="hljs-keyword">return</span> (OK); &#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 三、删除</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Locate</span><span class="hljs-params">(SeqList *L ,<span class="hljs-keyword">int</span> i,ElemType *e)</span></span><span class="hljs-function"><span class="hljs-comment">/*在顺序表L中删除第i个数据，并用指针参数e返回其值</span></span><span class="hljs-function"><span class="hljs-comment">i的合法取值为1&lt;=i&lt;=L.last+1*/</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> k;<span class="hljs-keyword">while</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L-&gt;last+<span class="hljs-number">1</span>)) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"删除位置不合法！"</span>);<span class="hljs-keyword">return</span>(error);&#125;*e=L-&gt;elem[i<span class="hljs-number">-1</span>]<span class="hljs-comment">/*将删除的元素存放到e所指的变量中*/</span><span class="hljs-keyword">for</span>(k=i; k&lt;=L-&gt;last; k++) &#123;L-&gt;elem[k<span class="hljs-number">-1</span>]=L-&gt;elem[k];<span class="hljs-comment">/*将后面的元素依次前移*/</span>L-&gt;last--;<span class="hljs-keyword">return</span> (ok);&#125;&#125;</code></pre></div><table><tr><td bgcolor=#FFC0CB><font  size=5> 四、有序表合并</td></tr></table><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(SeqList *LA,SeqList *LB,SeqList *LC)</span> </span>&#123;<span class="hljs-keyword">int</span> i,j,k,l;i=<span class="hljs-number">0</span>;j=<span class="hljs-number">0</span>;k=<span class="hljs-number">0</span>;<span class="hljs-comment">/*LC 为空表,设LC表的指示器k=0.</span><span class="hljs-comment">设两个指示器 i,j 分别指向表 LA 和 LB 的当前位置，初值均为 0*/</span><span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last&amp;&amp;j&lt;=LB-&gt;last) &#123;<span class="hljs-keyword">if</span>(LA-&gt;elem[i]&lt;=LB-&gt;elem[j]) &#123;LC-&gt;elem[k]=LA-&gt;elem[i];i++;k++;&#125; <span class="hljs-keyword">else</span> &#123;LC-&gt;elem[k]=LB-&gt;elem[j];j++;k++;&#125;&#125;<span class="hljs-comment">/*：LA 表和 LB 表的当前元素比较，小的元素进 LC 表，且该表的指</span><span class="hljs-comment">示器和 LC 表的指示器 k 均加 1 移向下一个位置。如此下去，直到 LA 或 LB 表</span><span class="hljs-comment">中一个表处理完毕为止。*/</span><span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last) &#123; <span class="hljs-comment">/*当表LA比表LB长时，则将表LA余下的元素赋给表LC*/</span>LC-&gt;elem[k]=LA-&gt;elem[i];i++;k++;&#125;<span class="hljs-keyword">while</span>(i&lt;=LA-&gt;last) &#123; <span class="hljs-comment">/*当表LB比表LA长时，则将表LB余下的元素赋给表LC*/</span>LC-&gt;elem[k]=LB-&gt;elem[j];j++;k++;&#125;LC-&gt;last=LA-&gt;last+LB-&gt;last+<span class="hljs-number">1</span>;&#125;</code></pre></div><table><tr><td bgcolor=#E6E6FA><font  size=6> 算法应用示例</td></tr></table><table><tr><td bgcolor=#FFC0CB><font  size=4> 分解顺序表为奇偶两部分</td></tr></table><blockquote><p>已知顺序表 L 中的数据元素类型为 int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为 O(n)，空间复杂度为 O（1）。</p></blockquote><p>【问题分析】<br>初见此题，可能会想到额外申请 1 个顺序表空间，之后依次从顺序表 L 中选<br>择奇数放入新表前部分，选择偶数放在新表的后半部分。但是题目要求空间复杂度为 O(1),很显然上述方法是不可行的。既然要求空间复杂度为 O(1)，说明只能借助 1 个辅助空间。</p><p>分析题目要求，其实只需要将位于表左半部分的偶数与位于表右半部分的奇数通过一个辅助变量进行交换即可，为此可以设置两个位置指示器 i 和 j,i 初值为 0，j 初值为 L-&gt;last。<br>当L-&gt;elem[i]为偶数，L-&gt;elem[j]为奇数时，则将 L-&gt;elem[i] 与 L-&gt;elem[j]交换；否则，L-&gt;elem[i]为奇数,i++, L-&gt;elem[j]为偶数，j++。这样既可以保证算法的时间复杂度为 O(n),亦可保证空间复杂度为 O（1）。<br>【算法描述】</p><div class="hljs"><pre><code class="hljs c">adjustsqlist(seqlist *l)&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=l-&gt;last,t;<span class="hljs-keyword">while</span>(i&lt;j)&#123;<span class="hljs-keyword">while</span>(l-&gt;elem[i]%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<span class="hljs-comment">/*从表的左半部分开始检测，若为奇数，则 i 加 1,直到找到偶数为止*/</span>i++;<span class="hljs-keyword">while</span>(l-&gt;elem[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">/*从表的左半部分开始检测，若为偶数，则 j 减 1,直到找到奇数为止*/</span>j--;<span class="hljs-keyword">if</span>(i&lt;j)&#123;t=l-&gt;elem[i];l-&gt;elem[i]=l-&gt;elem[j];l-&gt;elem[j]=t;&#125; &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/23/hello-world/"/>
    <url>/2019/12/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>练习5-2 找两个数中最大者</title>
    <link href="/2019/10/29/%E7%BB%83%E4%B9%A05-2%20%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%80%85/"/>
    <url>/2019/10/29/%E7%BB%83%E4%B9%A05-2%20%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%80%85/</url>
    
    <content type="html"><![CDATA[<p>本题要求对两个整数a和b，输出其中较大的数。<br>函数接口定义</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">( <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b )</span></span>;</code></pre></div><p>其中a和b是用户传入的参数，函数返回的是两者中较大的数</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">( <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b )</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>;<span class="hljs-keyword">if</span>(a&gt;b)&#123;<span class="hljs-built_in">max</span>=a;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">max</span>=b;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> a, b;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;a, &amp;b);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"max = %d\n"</span>, <span class="hljs-built_in">max</span>(a, b));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>基础训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PTA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>练习5-1 求m到n之和</title>
    <link href="/2019/10/29/%E7%BB%83%E4%B9%A05-1%20%E6%B1%82m%E5%88%B0n%E4%B9%8B%E5%92%8C/"/>
    <url>/2019/10/29/%E7%BB%83%E4%B9%A05-1%20%E6%B1%82m%E5%88%B0n%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>本题要求实现一个计算m~n（m&lt;n）之间所有整数的和的简单函数。<br>函数接口定义：</p><div class="hljs"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>( <span class="hljs-built_in">int</span> m, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> );</code></pre></div><p>其中m和n是用户传入的参数，保证有m&lt;n。函数返回的是m~n之间所有整数的和。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(m&lt;=n)&#123;sum = sum +m;m=m+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> m, n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;m, &amp;n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sum = %d\n"</span>, sum(m, n));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>基础训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PTA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>练习5-3 数字金字塔</title>
    <link href="/2019/10/29/%E7%BB%83%E4%B9%A05-3%20%E6%95%B0%E5%AD%97%E9%87%91%E5%AD%97%E5%A1%94/"/>
    <url>/2019/10/29/%E7%BB%83%E4%B9%A05-3%20%E6%95%B0%E5%AD%97%E9%87%91%E5%AD%97%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<p>本题要求实现函数输出n行数字金字塔。<br>函数接口定义：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pyramid</span><span class="hljs-params">( <span class="hljs-keyword">int</span> n )</span></span>;</code></pre></div><p>其中n是用户传入的参数，为[1, 9]的正整数。<br>要求函数按照如样例所示的格式打印出n行数字金字塔。<br>注意每个数字后面跟一个空格</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pyramid</span><span class="hljs-params">( <span class="hljs-keyword">int</span> n )</span> </span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> c=n;<span class="hljs-keyword">for</span>(a=<span class="hljs-number">1</span>; a&lt;=n; a+=<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(c=n; a&lt;c<span class="hljs-number">-1</span>; c-=<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);&#125;<span class="hljs-keyword">if</span>(a==n) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a);<span class="hljs-keyword">for</span>(b=<span class="hljs-number">1</span>; a&gt;b; b+=<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a);<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,a);<span class="hljs-keyword">for</span>(b=<span class="hljs-number">1</span>; a&gt;b; b+=<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);    pyramid(n);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    system(<span class="hljs-string">"pause"</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>练习题</category>
      
      <category>基础训练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PTA</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
